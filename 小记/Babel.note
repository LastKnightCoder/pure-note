{
  "editing": {
    "content": "",
    "preview": "",
    "tags": []
  },
  "notes": [
    {
      "content": "Babel 的功能包括两部分：\n\n- 转换语法\n- polyfill 新的 API，比如 Promise Set Map 这些 API\n\n所有的这些都是通过插件来实现的。\n\npreset 中包含了大量的插件，我们不需要一个个下载插件，然后配置，直接配置 preset 就可以了，并且还会根据 target，有条件的转换语法，并不是每个语法都会转换。\n\n除此之外，preset 还可以通过 useBuiltIns 选项来添加 polyfill，不过是全局添加的方式。\n\n可以通过插件 transform-runtime 来添加 polyfill，它不会添加到全局中，从而不会污染环境，但是他不会根据你的 taget 有条件的添加，而是你用到的都会添加，比如你的 taget 浏览器已经支持 Promise 了，但是 transform-runtime 还是会添加，但是这是不必要。\n\n官方文档的建议是 preset-env 的 useBuiltin 选项和 transform-runtime 不要同时使用，一般库作者会使用 transform-runtime，因为不会污染全局，而应用会使用 useBuiltIns，因为可以减少体积。\n\n难道没有兼得的方法吗，既可以条件添加，又不污染全局，有的，将 target 选项添加到顶层，抽离使用 babel-polyfills，它可以指定不同的 polyfill provider（由于历史原因，Babel 一直用的是 core-js，但是也有其他的 ployfill 库，如 es-shims），并且可以指定 polyfill 插入的方式，包括三种：\n\n- entry-global：对应 useBuiltIns: 'entry'\n- usage-global：对应 useBuiltIns: 'usage'\n- usage-pure：对应 transform-runtime，但是可以读取到 target 信息，实现条件引入\n\n仓库地址 [Babel Polyfills](https://github.com/babel/babel-polyfills)，我强烈推荐这种方式，将语法转换和 polyfill 分开配置，各司其职，插件间没有冲突。\n\n```note\ntransform-runtime 除了可以添加垫片，还提供了各种 helper，让需要使用到 helper 的地方直接导入，而不是每个文件都生产类似的代码，减少文件的体积。\n\n该功能依赖 @babel/runtim。\n\n如果需要用 transform-runtime polyfill 的话，那么就需要依赖 runtime-corejs2 或 runtime-corejs3。\n```\n\n参考:\n\n- [RFC: Rethink polyfilling story](https://github.com/babel/babel/issues/10008)\n",
      "preview": "<p>Babel 的功能包括两部分：</p>\n<ul>\n<li>转换语法</li>\n<li>polyfill 新的 API，比如 Promise Set Map 这些 API</li>\n</ul>\n<p>所有的这些都是通过插件来实现的。</p>\n<p>preset 中包含了大量的插件，我们不需要一个个下载插件，然后配置，直接配置 preset 就可以了，并且还会根据 target，有条件的转换语法，并不是每个语法都会转换。</p>\n<p>除此之外，preset 还可以通过 useBuiltIns 选项来添加 polyfill，不过是全局添加的方式。</p>\n<p>可以通过插件 transform-runtime 来添加 polyfill，它不会添加到全局中，从而不会污染环境，但是他不会根据你的 taget 有条件的添加，而是你用到的都会添加，比如你的 taget 浏览器已经支持 Promise 了，但是 transform-runtime 还是会添加，但是这是不必要。</p>\n<p>官方文档的建议是 preset-env 的 useBuiltin 选项和 transform-runtime 不要同时使用，一般库作者会使用 transform-runtime，因为不会污染全局，而应用会使用 useBuiltIns，因为可以减少体积。</p>\n<p>难道没有兼得的方法吗，既可以条件添加，又不污染全局，有的，将 target 选项添加到顶层，抽离使用 babel-polyfills，它可以指定不同的 polyfill provider（由于历史原因，Babel 一直用的是 core-js，但是也有其他的 ployfill 库，如 es-shims），并且可以指定 polyfill 插入的方式，包括三种：</p>\n<ul>\n<li>entry-global：对应 useBuiltIns: 'entry'</li>\n<li>usage-global：对应 useBuiltIns: 'usage'</li>\n<li>usage-pure：对应 transform-runtime，但是可以读取到 target 信息，实现条件引入</li>\n</ul>\n<p>仓库地址 <a aria-label-position=\"top\" aria-label=\"https://github.com/babel/babel-polyfills\" rel=\"noopener\" class=\"external-link\" href=\"https://github.com/babel/babel-polyfills\" target=\"_blank\">Babel Polyfills</a>，我强烈推荐这种方式，将语法转换和 polyfill 分开配置，各司其职，插件间没有冲突。</p>\n<div class=\"block-language-note custom-block note\"><p class=\"custom-block-title\">Note</p><p>transform-runtime 除了可以添加垫片，还提供了各种 helper，让需要使用到 helper 的地方直接导入，而不是每个文件都生产类似的代码，减少文件的体积。</p>\n<p>该功能依赖 @babel/runtim。</p>\n<p>如果需要用 transform-runtime polyfill 的话，那么就需要依赖 runtime-corejs2 或 runtime-corejs3。</p></div>\n<p>参考:</p>\n<ul>\n<li><a aria-label-position=\"top\" aria-label=\"https://github.com/babel/babel/issues/10008\" rel=\"noopener\" class=\"external-link\" href=\"https://github.com/babel/babel/issues/10008\" target=\"_blank\">RFC: Rethink polyfilling story</a></li>\n</ul>",
      "tags": [
        "Babel",
        "polyfill"
      ],
      "createTime": 1675234841430,
      "updateTime": 1675236653524,
      "uuid": "7ec82ea7-f3c0-46db-9df7-f9d7305af1c9",
      "isCreated": true
    },
    {
      "content": "## The current relationship between Babel and core-js\n\nBabel is a compiler, `core-js` is a polyfill.\n\nA compiler is used to make modern syntax work in old browsers; a polyfill is used to make modern native functions work in old browsers. You usually want to use both, so that you can write modern code and run it in old browsers without problems.\n\nHowever, compilers and polyfills are two independent units. There are a lot of compiler you can choose (Babel, TypeScript, Traceur, swc, ...), and a lot of polyfills you can choose (core-js, es-shims, polyfill.io, ...).\n\nYou can choose them independently, but for historical reasons (and because `core-js` is a really good polyfill!) so far Babel has made it easier to use `core-js`.\n\n### What does the Babel compiler do with `core-js`?\n\nBabel internally does not depend on `core-js`. What it does is providing a simple way of automatically generate imports to `core-js` in your code.\n\nBabel provides a plugin to generate imports to core-js in your code. It's then your code that depends on `core-js`.\n\n```js\n// input (your code):\nSymbol();\n\n// output (your compiled code):\nimport \"core-js/modules/es.symbol\";\nSymbol();\n```\n\nIn order to generate those imports, we don't need to depend on core-js: we handle your code as if it was a simple string, similarly to how this function does:\n\n```js\nfunction addCoreJSImport(input) {\n  return `import \"core-js/modules/es.symbol\";\\n` + input;\n}\n```\n\n(well, it's not that simple! 😛)\n\nBe careful though: even if Babel doesn't depend on core-js, your code will do!\n\nIs there any other way in which Babel directly depends on core-js?\n\nKind of. While the Babel compiler itself doesn't depend on core-js, we provide a few runtime packages that might be used at runtime by your application that depend on it.\n\n- @babel/polyfill is a \"proxy package\": all what it does is importing regenerator-runtime (a runtime helper used for generators) and core-js 2. This package has been deprecated at least since the release of core-js 3 in favor of the direct inclusion of those two other packages.\nOne of the reasons we deprecated it is that many users didn't understand that @babel/polyfill just imported core-js code, effectively not giving to the project the recognition it deserved.\n- (NOTE: @babel/runtime contains all the Babel runtime helpers.)\n- @babel/runtime-corejs2 is @babel/runtime + \"proxy files\" to core-js. Imports to this package are injected by @babel/plugin-transform-runtime, similarly to how @babel/preset-env injects imports to core-js.\n- @babel/runtime-corejs3 is the same, but depending on core-js-pure 3 (which is mostly core-js but without attaching polyfills to the global scope).\n\nWith the polyfill providers proposed in this RFC, we will just generate imports to core-js-pure when using @babel/plugin-transform-runtime rather than using the @babel/runtime-corejs3 \"proxy\".",
      "preview": "<h2 data-heading=\"The current relationship between Babel and core-js\">The current relationship between Babel and core-js</h2>\n<p>Babel is a compiler, <code>core-js</code> is a polyfill.</p>\n<p>A compiler is used to make modern syntax work in old browsers; a polyfill is used to make modern native functions work in old browsers. You usually want to use both, so that you can write modern code and run it in old browsers without problems.</p>\n<p>However, compilers and polyfills are two independent units. There are a lot of compiler you can choose (Babel, TypeScript, Traceur, swc, ...), and a lot of polyfills you can choose (core-js, es-shims, polyfill.io, ...).</p>\n<p>You can choose them independently, but for historical reasons (and because <code>core-js</code> is a really good polyfill!) so far Babel has made it easier to use <code>core-js</code>.</p>\n<h3 data-heading=\"What does the Babel compiler do with `core-js`?\">What does the Babel compiler do with <code>core-js</code>?</h3>\n<p>Babel internally does not depend on <code>core-js</code>. What it does is providing a simple way of automatically generate imports to <code>core-js</code> in your code.</p>\n<p>Babel provides a plugin to generate imports to core-js in your code. It's then your code that depends on <code>core-js</code>.</p>\n<pre class=\"language-js\" tabindex=\"0\"><code class=\"language-js is-loaded\"><span class=\"token comment\">// input (your code):</span>\n<span class=\"token known-class-name class-name\">Symbol</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// output (your compiled code):</span>\n<span class=\"token keyword module\">import</span> <span class=\"token string\">\"core-js/modules/es.symbol\"</span><span class=\"token punctuation\">;</span>\n<span class=\"token known-class-name class-name\">Symbol</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code><button class=\"copy-code-button\">复制</button></pre>\n<p>In order to generate those imports, we don't need to depend on core-js: we handle your code as if it was a simple string, similarly to how this function does:</p>\n<pre class=\"language-js\" tabindex=\"0\"><code class=\"language-js is-loaded\"><span class=\"token keyword\">function</span> <span class=\"token function\">addCoreJSImport</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">input</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword control-flow\">return</span> <span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token string\">import \"core-js/modules/es.symbol\";\\n</span><span class=\"token template-punctuation string\">`</span></span> <span class=\"token operator\">+</span> input<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code><button class=\"copy-code-button\">复制</button></pre>\n<p>(well, it's not that simple! 😛)</p>\n<p>Be careful though: even if Babel doesn't depend on core-js, your code will do!</p>\n<p>Is there any other way in which Babel directly depends on core-js?</p>\n<p>Kind of. While the Babel compiler itself doesn't depend on core-js, we provide a few runtime packages that might be used at runtime by your application that depend on it.</p>\n<ul>\n<li>@babel/polyfill is a \"proxy package\": all what it does is importing regenerator-runtime (a runtime helper used for generators) and core-js 2. This package has been deprecated at least since the release of core-js 3 in favor of the direct inclusion of those two other packages.\nOne of the reasons we deprecated it is that many users didn't understand that @babel/polyfill just imported core-js code, effectively not giving to the project the recognition it deserved.</li>\n<li>(NOTE: @babel/runtime contains all the Babel runtime helpers.)</li>\n<li>@babel/runtime-corejs2 is @babel/runtime + \"proxy files\" to core-js. Imports to this package are injected by @babel/plugin-transform-runtime, similarly to how @babel/preset-env injects imports to core-js.</li>\n<li>@babel/runtime-corejs3 is the same, but depending on core-js-pure 3 (which is mostly core-js but without attaching polyfills to the global scope).</li>\n</ul>\n<p>With the polyfill providers proposed in this RFC, we will just generate imports to core-js-pure when using @babel/plugin-transform-runtime rather than using the @babel/runtime-corejs3 \"proxy\".</p>",
      "tags": [
        "Babel",
        "polyfill",
        "core-js"
      ],
      "createTime": 1675215144785,
      "updateTime": 1675215144785,
      "uuid": "9ad6e113-7e1f-4753-b579-bf7e9785c998",
      "isCreated": true
    }
  ]
}