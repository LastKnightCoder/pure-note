{
  "editing": {
    "content": "",
    "preview": "",
    "tags": []
  },
  "notes": [
    {
      "content": "在 TypeScript 中，你可能遇见过以下这样“看起来不太对，但竟然能正常运行”的代码\n\n```ts\nclass Cat {\n  eat() { }\n}\n\nclass Dog {\n  eat() { }\n}\n\nfunction feedCat(cat: Cat) { }\n\nfeedCat(new Dog())\n```\n\n结构化类型系统（鸭子类型），TypeScript 比较两个类型并非通过类型的名称，而是比较这两个类型上实际拥有的属性与方法。也就是说，这里实际上是比较 Cat 类型上的属性是否都存在于 Dog 类型上。\n\n标称类型系统要求两个可兼容的类型，其名称必须是完全一致的\n\n```ts\ntype USD = number;\ntype CNY = number;\n\nconst CNYCount: CNY = 200;\nconst USDCount: USD = 200;\n\nfunction addCNY(source: CNY, input: CNY) {\n  return source + input;\n}\n\naddCNY(CNYCount, USDCount)\n```\n\nUSD 与 CNY （分别代表美元单位与人民币单位）被认为是两个完全一致的类型，因此在 addCNY 函数中可以传入 USD 类型的变量。这就很离谱了，人民币与美元这两个单位实际的意义并不一致，怎么能进行相加？\n\nTypeScript 中模拟标称类型系统\n\n```ts\nexport declare class TagProtector<T extends string> {\n  protected __tag__: T;\n}\n\nexport type Nominal<T, U extends string> = T & TagProtector<U>;\n```\n\n```ts\nexport type CNY = Nominal<number, 'CNY'>;\n\nexport type USD = Nominal<number, 'USD'>;\n\nconst CNYCount = 100 as CNY;\n\nconst USDCount = 100 as USD;\n\nfunction addCNY(source: CNY, input: CNY) {\n  return (source + input) as CNY;\n}\n\naddCNY(CNYCount, CNYCount);\n\n// 报错了！\naddCNY(CNYCount, USDCount);\n```\n\n还可以从逻辑层面入手进一步确保安全性\n\n```ts\nclass CNY {\n  private __tag!: void;\n  constructor(public value: number) {}\n}\nclass USD {\n  private __tag!: void;\n  constructor(public value: number) {}\n}\n```\n\n```ts\nconst CNYCount = new CNY(100);\nconst USDCount = new USD(100);\n\nfunction addCNY(source: CNY, input: CNY) {\n  return (source.value + input.value);\n}\n\naddCNY(CNYCount, CNYCount);\n// 报错了！\naddCNY(CNYCount, USDCount);\n```\n\n这两种方式的本质都是通过非公开（即 private / protected ）的额外属性实现了类型信息的附加，从而使得结构化类型系统将结构一致的两个类型也视为不兼容的。\n\n在 TypeScript 中我们可以通过类型或者逻辑的方式来模拟标称类型，这两种方式其实并没有非常明显的优劣之分，基于类型实现更加轻量，你的代码逻辑不会受到影响，但难以进行额外的逻辑检查工作。而使用逻辑实现稍显繁琐，但你能够进行更进一步或更细致的约束。\n",
      "preview": "<p>在 TypeScript 中，你可能遇见过以下这样“看起来不太对，但竟然能正常运行”的代码</p>\n<pre class=\"language-ts\" tabindex=\"0\"><code class=\"language-ts is-loaded\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Cat</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">eat</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">Dog</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">eat</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">function</span> <span class=\"token function\">feedCat</span><span class=\"token punctuation\">(</span>cat<span class=\"token operator\">:</span> Cat<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> <span class=\"token punctuation\">}</span>\n\n<span class=\"token function\">feedCat</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">Dog</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n</code><button class=\"copy-code-button\">复制</button></pre>\n<p>结构化类型系统（鸭子类型），TypeScript 比较两个类型并非通过类型的名称，而是比较这两个类型上实际拥有的属性与方法。也就是说，这里实际上是比较 Cat 类型上的属性是否都存在于 Dog 类型上。</p>\n<p>标称类型系统要求两个可兼容的类型，其名称必须是完全一致的</p>\n<pre class=\"language-ts\" tabindex=\"0\"><code class=\"language-ts is-loaded\"><span class=\"token keyword\">type</span> <span class=\"token class-name\"><span class=\"token constant\">USD</span></span> <span class=\"token operator\">=</span> <span class=\"token builtin\">number</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">type</span> <span class=\"token class-name\"><span class=\"token constant\">CNY</span></span> <span class=\"token operator\">=</span> <span class=\"token builtin\">number</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">const</span> CNYCount<span class=\"token operator\">:</span> <span class=\"token constant\">CNY</span> <span class=\"token operator\">=</span> <span class=\"token number\">200</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> USDCount<span class=\"token operator\">:</span> <span class=\"token constant\">USD</span> <span class=\"token operator\">=</span> <span class=\"token number\">200</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">function</span> <span class=\"token function\">addCNY</span><span class=\"token punctuation\">(</span>source<span class=\"token operator\">:</span> <span class=\"token constant\">CNY</span><span class=\"token punctuation\">,</span> input<span class=\"token operator\">:</span> <span class=\"token constant\">CNY</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> source <span class=\"token operator\">+</span> input<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token function\">addCNY</span><span class=\"token punctuation\">(</span>CNYCount<span class=\"token punctuation\">,</span> USDCount<span class=\"token punctuation\">)</span>\n</code><button class=\"copy-code-button\">复制</button></pre>\n<p>USD 与 CNY （分别代表美元单位与人民币单位）被认为是两个完全一致的类型，因此在 addCNY 函数中可以传入 USD 类型的变量。这就很离谱了，人民币与美元这两个单位实际的意义并不一致，怎么能进行相加？</p>\n<p>TypeScript 中模拟标称类型系统</p>\n<pre class=\"language-ts\" tabindex=\"0\"><code class=\"language-ts is-loaded\"><span class=\"token keyword\">export</span> <span class=\"token keyword\">declare</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">TagProtector<span class=\"token operator\">&lt;</span><span class=\"token constant\">T</span> <span class=\"token keyword\">extends</span> <span class=\"token builtin\">string</span><span class=\"token operator\">&gt;</span></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">protected</span> __tag__<span class=\"token operator\">:</span> <span class=\"token constant\">T</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">type</span> <span class=\"token class-name\">Nominal<span class=\"token operator\">&lt;</span><span class=\"token constant\">T</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">U</span> <span class=\"token keyword\">extends</span> <span class=\"token builtin\">string</span><span class=\"token operator\">&gt;</span></span> <span class=\"token operator\">=</span> <span class=\"token constant\">T</span> <span class=\"token operator\">&amp;</span> TagProtector<span class=\"token operator\">&lt;</span><span class=\"token constant\">U</span><span class=\"token operator\">&gt;</span><span class=\"token punctuation\">;</span>\n</code><button class=\"copy-code-button\">复制</button></pre>\n<pre class=\"language-ts\" tabindex=\"0\"><code class=\"language-ts is-loaded\"><span class=\"token keyword\">export</span> <span class=\"token keyword\">type</span> <span class=\"token class-name\"><span class=\"token constant\">CNY</span></span> <span class=\"token operator\">=</span> Nominal<span class=\"token operator\">&lt;</span><span class=\"token builtin\">number</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'CNY'</span><span class=\"token operator\">&gt;</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">type</span> <span class=\"token class-name\"><span class=\"token constant\">USD</span></span> <span class=\"token operator\">=</span> Nominal<span class=\"token operator\">&lt;</span><span class=\"token builtin\">number</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'USD'</span><span class=\"token operator\">&gt;</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">const</span> CNYCount <span class=\"token operator\">=</span> <span class=\"token number\">100</span> <span class=\"token keyword\">as</span> <span class=\"token constant\">CNY</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">const</span> USDCount <span class=\"token operator\">=</span> <span class=\"token number\">100</span> <span class=\"token keyword\">as</span> <span class=\"token constant\">USD</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">function</span> <span class=\"token function\">addCNY</span><span class=\"token punctuation\">(</span>source<span class=\"token operator\">:</span> <span class=\"token constant\">CNY</span><span class=\"token punctuation\">,</span> input<span class=\"token operator\">:</span> <span class=\"token constant\">CNY</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span>source <span class=\"token operator\">+</span> input<span class=\"token punctuation\">)</span> <span class=\"token keyword\">as</span> <span class=\"token constant\">CNY</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token function\">addCNY</span><span class=\"token punctuation\">(</span>CNYCount<span class=\"token punctuation\">,</span> CNYCount<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// 报错了！</span>\n<span class=\"token function\">addCNY</span><span class=\"token punctuation\">(</span>CNYCount<span class=\"token punctuation\">,</span> USDCount<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code><button class=\"copy-code-button\">复制</button></pre>\n<p>还可以从逻辑层面入手进一步确保安全性</p>\n<pre class=\"language-ts\" tabindex=\"0\"><code class=\"language-ts is-loaded\"><span class=\"token keyword\">class</span> <span class=\"token class-name\"><span class=\"token constant\">CNY</span></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">private</span> __tag<span class=\"token operator\">!</span><span class=\"token operator\">:</span> <span class=\"token keyword\">void</span><span class=\"token punctuation\">;</span>\n  <span class=\"token function\">constructor</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">public</span> value<span class=\"token operator\">:</span> <span class=\"token builtin\">number</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">class</span> <span class=\"token class-name\"><span class=\"token constant\">USD</span></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">private</span> __tag<span class=\"token operator\">!</span><span class=\"token operator\">:</span> <span class=\"token keyword\">void</span><span class=\"token punctuation\">;</span>\n  <span class=\"token function\">constructor</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">public</span> value<span class=\"token operator\">:</span> <span class=\"token builtin\">number</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n</code><button class=\"copy-code-button\">复制</button></pre>\n<pre class=\"language-ts\" tabindex=\"0\"><code class=\"language-ts is-loaded\"><span class=\"token keyword\">const</span> CNYCount <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\"><span class=\"token constant\">CNY</span></span><span class=\"token punctuation\">(</span><span class=\"token number\">100</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> USDCount <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\"><span class=\"token constant\">USD</span></span><span class=\"token punctuation\">(</span><span class=\"token number\">100</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">function</span> <span class=\"token function\">addCNY</span><span class=\"token punctuation\">(</span>source<span class=\"token operator\">:</span> <span class=\"token constant\">CNY</span><span class=\"token punctuation\">,</span> input<span class=\"token operator\">:</span> <span class=\"token constant\">CNY</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span>source<span class=\"token punctuation\">.</span>value <span class=\"token operator\">+</span> input<span class=\"token punctuation\">.</span>value<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token function\">addCNY</span><span class=\"token punctuation\">(</span>CNYCount<span class=\"token punctuation\">,</span> CNYCount<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">// 报错了！</span>\n<span class=\"token function\">addCNY</span><span class=\"token punctuation\">(</span>CNYCount<span class=\"token punctuation\">,</span> USDCount<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code><button class=\"copy-code-button\">复制</button></pre>\n<p>这两种方式的本质都是通过非公开（即 private / protected ）的额外属性实现了类型信息的附加，从而使得结构化类型系统将结构一致的两个类型也视为不兼容的。</p>\n<p>在 TypeScript 中我们可以通过类型或者逻辑的方式来模拟标称类型，这两种方式其实并没有非常明显的优劣之分，基于类型实现更加轻量，你的代码逻辑不会受到影响，但难以进行额外的逻辑检查工作。而使用逻辑实现稍显繁琐，但你能够进行更进一步或更细致的约束。</p>",
      "tags": [
        "结构化类型系统"
      ],
      "createTime": 1665892717608,
      "updateTime": 1665892717608,
      "uuid": "614598ed-8bbe-4dce-b756-aa3a974ad1b1",
      "isCreated": true
    },
    {
      "content": "这个时候，我们就该请出泛型\n",
      "preview": "<p>这个时候，我们就该请出泛型</p>",
      "tags": [],
      "createTime": 1665884386672,
      "updateTime": 1665884386672,
      "uuid": "e8ca8af8-f852-4d07-8dde-cddd3d67c2e9",
      "isCreated": true,
      "isDeleted": true
    },
    {
      "content": "提前看一个 TypeScript 的内置工具类型实现\n\n```ts\ntype Partial<T> = {\n    [P in keyof T]?: T[P];\n};\n```\n\n条件类型\n\n```ts\ntype IsEqual<T> = T extends true ? 1 : 2;\n\ntype A = IsEqual<true>; // 1\ntype B = IsEqual<false>; // 2\ntype C = IsEqual<'linbudu'>; // 2\n```\n\n泛型同样有着默认值的设定\n\n```ts\ntype Factory<T = boolean> = T | number | string;\nconst foo: Factory = false;\n```\n\n泛型约束\n\n```ts\ntype ResStatus<ResCode extends number> = ResCode extends 10000 | 10001 | 10002\n  ? 'success'\n  : 'failure';\ntype Res1 = ResStatus<10000>; // \"success\"\ntype Res2 = ResStatus<20000>; // \"failure\"\n\ntype Res3 = ResStatus<'10000'>; // 类型“string”不满足约束“number”。\n```\n\n```ts\ntype ResStatus<ResCode extends number = 10000> = ResCode extends 10000 | 10001 | 10002\n  ? 'success'\n  : 'failure';\n\ntype Res4 = ResStatus; // \"success\"\n```\n\n多泛型关联\n\n```ts\ntype Conditional<Type, Condition, TruthyResult, FalsyResult> =\n  Type extends Condition ? TruthyResult : FalsyResult;\n\n//  \"passed!\"\ntype Result1 = Conditional<'linbudu', string, 'passed!', 'rejected!'>;\n\n// \"rejected!\"\ntype Result2 = Conditional<'linbudu', boolean, 'passed!', 'rejected!'>;\n```\n\n```ts\ninterface IRes<TData = unknown> {\n  code: number;\n  error?: string;\n  data: TData;\n}\n\ninterface IUserProfileRes {\n  name: string;\n  homepage: string;\n  avatar: string;\n}\n\nfunction fetchUserProfile(): Promise<IRes<IUserProfileRes>> {}\n\ntype StatusSucceed = boolean;\nfunction handleOperation(): Promise<IRes<StatusSucceed>> {}\n```\n\n泛型嵌套的场景也非常常用，比如对存在分页结构的数据，我们也可以将其分页的响应结构抽离出来\n\n```ts\ninterface IPaginationRes<TItem = unknown> {\n  data: TItem[];\n  page: number;\n  totalCount: number;\n  hasNextPage: boolean;\n}\n\nfunction fetchUserProfileList(): Promise<IRes<IPaginationRes<IUserProfileRes>>> {}\n```\n\n有这么一个函数，它可以接受多个类型的参数并进行对应处理，比如：\n\n- 对于字符串，返回部分截取；\n- 对于数字，返回它的 n 倍；\n- 对于对象，修改它的属性并返回。\n\n```ts\nfunction handle(input: string | number | {}): string | number | {} {}\nconst shouldBeString = handle(\"linbudu\");\nconst shouldBeNumber = handle(599);\nconst shouldBeObject = handle({ name: \"linbudu\" });\n```\n\n虽然我们约束了入参的类型，但返回值的类型并没有像我们预期的那样和入参关联起来，上面三个调用结果的类型仍然是一个宽泛的联合类型 string | number | {}。难道要用重载一个个声明可能的关联关系？\n\n```ts\nfunction handle(input: string): string\nfunction handle(input: number): number\nfunction handle(input: {}): {}\nfunction handle(input: string | number | {}): string | number | {} { }\n```\n\n这个时候，我们就该请出泛型\n\n```ts\nfunction handle<T>(input: T): T {}\n```\n\n在这个函数接收到参数时，T 会自动地被填充为这个参数的类型。这也就意味着你不再需要预先确定参数的可能类型了，而在返回值与参数类型关联的情况下，也可以通过泛型参数来进行运算。\n\n```ts\nfunction swap<T, U>([start, end]: [T, U]): [U, T] {\n  return [end, start];\n}\n\nconst swapped1 = swap([\"linbudu\", 599]);\nconst swapped2 = swap([null, 599]);\nconst swapped3 = swap([{ name: \"linbudu\" }, {}]);\n```\n\n```ts\npick<T extends object, U extends keyof T>(object: T, ...props: Array<U>): Pick<T, U>;\n```\n\n箭头函数的泛型\n\n```ts\nconst handle = <T>(input: T): T => {}\n```\n\n在 tsx 文件中泛型的尖括号可能会造成报错，编译器无法识别这是一个组件还是一个泛型，此时你可以让它长得更像泛型一些\n\n```ts\nconst handle = <T extends any>(input: T): T => {}\n```\n\n内置方法中的泛型\n\nPromise\n\n```ts\nfunction p() {\n  return new Promise<boolean>((resolve, reject) => {\n    resolve(true);\n  });\n}\n```\n\n在 TypeScript 内部的 Promise 类型声明中同样是通过泛型实现\n\n```ts\ninterface PromiseConstructor {\n    resolve<T>(value: T | PromiseLike<T>): Promise<T>;\n}\n\ndeclare var Promise: PromiseConstructor;\n```\n\n数组 Array<T>\n\n```ts\nconst arr: Array<number> = [1, 2, 3];\n\n// 类型“string”的参数不能赋给类型“number”的参数。\narr.push('linbudu');\n// 类型“string”的参数不能赋给类型“number”的参数。\narr.includes('linbudu');\n\n// number | undefined\narr.find(() => false);\n\n// 第一种 reduce\narr.reduce((prev, curr, idx, arr) => {\n  return prev;\n}, 1);\n\n// 第二种 reduce\n// 报错：不能将 number 类型的值赋值给 never 类型\narr.reduce((prev, curr, idx, arr) => {\n  return [...prev, curr]\n}, []);\n```\n\nreduce 方法是相对特殊的一个，它的类型声明存在几种不同的重载：\n\n- 当你不传入初始值时，泛型参数会从数组的元素类型中进行填充。\n- 当你传入初始值时，如果初始值的类型与数组元素类型一致，则使用数组的元素类型进行填充。即这里第一个 reduce 调用。\n- 当你传入一个数组类型的初始值，比如这里的第二个 reduce 调用，reduce 的泛型参数会默认从这个初始值推导出的类型进行填充，如这里是 never[]。\n\n第三种情况也就意味着信息不足，无法推导出正确的类型，我们可以手动传入泛型参数来解决\n\n```ts\narr.reduce<number[]>((prev, curr, idx, arr) => {\n  return prev;\n}, []);\n```\n\nReact\n\n```ts\nconst [state, setState] = useState<number[]>([]);\n// 不传入默认值，则类型为 number[] | undefined\nconst [state, setState] = useState<number[]>();\n\n// 体现在 ref.current 上\nconst ref = useRef<number>();\n\nconst context =  createContext<ContextType>({});\n```\n\n\n",
      "preview": "<p>提前看一个 TypeScript 的内置工具类型实现</p>\n<pre class=\"language-ts\" tabindex=\"0\"><code class=\"language-ts is-loaded\"><span class=\"token keyword\">type</span> <span class=\"token class-name\">Partial<span class=\"token operator\">&lt;</span><span class=\"token constant\">T</span><span class=\"token operator\">&gt;</span></span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token punctuation\">[</span><span class=\"token constant\">P</span> <span class=\"token keyword\">in</span> <span class=\"token keyword\">keyof</span> <span class=\"token constant\">T</span><span class=\"token punctuation\">]</span><span class=\"token operator\">?</span><span class=\"token operator\">:</span> <span class=\"token constant\">T</span><span class=\"token punctuation\">[</span><span class=\"token constant\">P</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n</code><button class=\"copy-code-button\">复制</button></pre>\n<p>条件类型</p>\n<pre class=\"language-ts\" tabindex=\"0\"><code class=\"language-ts is-loaded\"><span class=\"token keyword\">type</span> <span class=\"token class-name\">IsEqual<span class=\"token operator\">&lt;</span><span class=\"token constant\">T</span><span class=\"token operator\">&gt;</span></span> <span class=\"token operator\">=</span> <span class=\"token constant\">T</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\"><span class=\"token boolean\">true</span></span> <span class=\"token operator\">?</span> <span class=\"token number\">1</span> <span class=\"token operator\">:</span> <span class=\"token number\">2</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">type</span> <span class=\"token class-name\"><span class=\"token constant\">A</span></span> <span class=\"token operator\">=</span> IsEqual<span class=\"token operator\">&lt;</span><span class=\"token boolean\">true</span><span class=\"token operator\">&gt;</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 1</span>\n<span class=\"token keyword\">type</span> <span class=\"token class-name\"><span class=\"token constant\">B</span></span> <span class=\"token operator\">=</span> IsEqual<span class=\"token operator\">&lt;</span><span class=\"token boolean\">false</span><span class=\"token operator\">&gt;</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 2</span>\n<span class=\"token keyword\">type</span> <span class=\"token class-name\"><span class=\"token constant\">C</span></span> <span class=\"token operator\">=</span> IsEqual<span class=\"token operator\">&lt;</span><span class=\"token string\">'linbudu'</span><span class=\"token operator\">&gt;</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 2</span>\n</code><button class=\"copy-code-button\">复制</button></pre>\n<p>泛型同样有着默认值的设定</p>\n<pre class=\"language-ts\" tabindex=\"0\"><code class=\"language-ts is-loaded\"><span class=\"token keyword\">type</span> <span class=\"token class-name\">Factory<span class=\"token operator\">&lt;</span><span class=\"token constant\">T</span> <span class=\"token operator\">=</span> <span class=\"token builtin\">boolean</span><span class=\"token operator\">&gt;</span></span> <span class=\"token operator\">=</span> <span class=\"token constant\">T</span> <span class=\"token operator\">|</span> <span class=\"token builtin\">number</span> <span class=\"token operator\">|</span> <span class=\"token builtin\">string</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> foo<span class=\"token operator\">:</span> Factory <span class=\"token operator\">=</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span>\n</code><button class=\"copy-code-button\">复制</button></pre>\n<p>泛型约束</p>\n<pre class=\"language-ts\" tabindex=\"0\"><code class=\"language-ts is-loaded\"><span class=\"token keyword\">type</span> <span class=\"token class-name\">ResStatus<span class=\"token operator\">&lt;</span>ResCode <span class=\"token keyword\">extends</span> <span class=\"token builtin\">number</span><span class=\"token operator\">&gt;</span></span> <span class=\"token operator\">=</span> ResCode <span class=\"token keyword\">extends</span> <span class=\"token number\">10000</span> <span class=\"token operator\">|</span> <span class=\"token number\">10001</span> <span class=\"token operator\">|</span> <span class=\"token number\">10002</span>\n  <span class=\"token operator\">?</span> <span class=\"token string\">'success'</span>\n  <span class=\"token operator\">:</span> <span class=\"token string\">'failure'</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">type</span> <span class=\"token class-name\">Res1</span> <span class=\"token operator\">=</span> ResStatus<span class=\"token operator\">&lt;</span><span class=\"token number\">10000</span><span class=\"token operator\">&gt;</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// \"success\"</span>\n<span class=\"token keyword\">type</span> <span class=\"token class-name\">Res2</span> <span class=\"token operator\">=</span> ResStatus<span class=\"token operator\">&lt;</span><span class=\"token number\">20000</span><span class=\"token operator\">&gt;</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// \"failure\"</span>\n\n<span class=\"token keyword\">type</span> <span class=\"token class-name\">Res3</span> <span class=\"token operator\">=</span> ResStatus<span class=\"token operator\">&lt;</span><span class=\"token string\">'10000'</span><span class=\"token operator\">&gt;</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 类型“string”不满足约束“number”。</span>\n</code><button class=\"copy-code-button\">复制</button></pre>\n<pre class=\"language-ts\" tabindex=\"0\"><code class=\"language-ts is-loaded\"><span class=\"token keyword\">type</span> <span class=\"token class-name\">ResStatus<span class=\"token operator\">&lt;</span>ResCode <span class=\"token keyword\">extends</span> <span class=\"token builtin\">number</span> <span class=\"token operator\">=</span> <span class=\"token number\">10000</span><span class=\"token operator\">&gt;</span></span> <span class=\"token operator\">=</span> ResCode <span class=\"token keyword\">extends</span> <span class=\"token number\">10000</span> <span class=\"token operator\">|</span> <span class=\"token number\">10001</span> <span class=\"token operator\">|</span> <span class=\"token number\">10002</span>\n  <span class=\"token operator\">?</span> <span class=\"token string\">'success'</span>\n  <span class=\"token operator\">:</span> <span class=\"token string\">'failure'</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">type</span> <span class=\"token class-name\">Res4</span> <span class=\"token operator\">=</span> ResStatus<span class=\"token punctuation\">;</span> <span class=\"token comment\">// \"success\"</span>\n</code><button class=\"copy-code-button\">复制</button></pre>\n<p>多泛型关联</p>\n<pre class=\"language-ts\" tabindex=\"0\"><code class=\"language-ts is-loaded\"><span class=\"token keyword\">type</span> <span class=\"token class-name\">Conditional<span class=\"token operator\">&lt;</span>Type<span class=\"token punctuation\">,</span> Condition<span class=\"token punctuation\">,</span> TruthyResult<span class=\"token punctuation\">,</span> FalsyResult<span class=\"token operator\">&gt;</span></span> <span class=\"token operator\">=</span>\n  Type <span class=\"token keyword\">extends</span> <span class=\"token class-name\">Condition</span> <span class=\"token operator\">?</span> TruthyResult <span class=\"token operator\">:</span> FalsyResult<span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">//  \"passed!\"</span>\n<span class=\"token keyword\">type</span> <span class=\"token class-name\">Result1</span> <span class=\"token operator\">=</span> Conditional<span class=\"token operator\">&lt;</span><span class=\"token string\">'linbudu'</span><span class=\"token punctuation\">,</span> <span class=\"token builtin\">string</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'passed!'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'rejected!'</span><span class=\"token operator\">&gt;</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// \"rejected!\"</span>\n<span class=\"token keyword\">type</span> <span class=\"token class-name\">Result2</span> <span class=\"token operator\">=</span> Conditional<span class=\"token operator\">&lt;</span><span class=\"token string\">'linbudu'</span><span class=\"token punctuation\">,</span> <span class=\"token builtin\">boolean</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'passed!'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'rejected!'</span><span class=\"token operator\">&gt;</span><span class=\"token punctuation\">;</span>\n</code><button class=\"copy-code-button\">复制</button></pre>\n<pre class=\"language-ts\" tabindex=\"0\"><code class=\"language-ts is-loaded\"><span class=\"token keyword\">interface</span> <span class=\"token class-name\">IRes<span class=\"token operator\">&lt;</span>TData <span class=\"token operator\">=</span> <span class=\"token builtin\">unknown</span><span class=\"token operator\">&gt;</span></span> <span class=\"token punctuation\">{</span>\n  code<span class=\"token operator\">:</span> <span class=\"token builtin\">number</span><span class=\"token punctuation\">;</span>\n  error<span class=\"token operator\">?</span><span class=\"token operator\">:</span> <span class=\"token builtin\">string</span><span class=\"token punctuation\">;</span>\n  data<span class=\"token operator\">:</span> TData<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">interface</span> <span class=\"token class-name\">IUserProfileRes</span> <span class=\"token punctuation\">{</span>\n  name<span class=\"token operator\">:</span> <span class=\"token builtin\">string</span><span class=\"token punctuation\">;</span>\n  homepage<span class=\"token operator\">:</span> <span class=\"token builtin\">string</span><span class=\"token punctuation\">;</span>\n  avatar<span class=\"token operator\">:</span> <span class=\"token builtin\">string</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">function</span> <span class=\"token function\">fetchUserProfile</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token builtin\">Promise</span><span class=\"token operator\">&lt;</span>IRes<span class=\"token operator\">&lt;</span>IUserProfileRes<span class=\"token operator\">&gt;&gt;</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">type</span> <span class=\"token class-name\">StatusSucceed</span> <span class=\"token operator\">=</span> <span class=\"token builtin\">boolean</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">handleOperation</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token builtin\">Promise</span><span class=\"token operator\">&lt;</span>IRes<span class=\"token operator\">&lt;</span>StatusSucceed<span class=\"token operator\">&gt;&gt;</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n</code><button class=\"copy-code-button\">复制</button></pre>\n<p>泛型嵌套的场景也非常常用，比如对存在分页结构的数据，我们也可以将其分页的响应结构抽离出来</p>\n<pre class=\"language-ts\" tabindex=\"0\"><code class=\"language-ts is-loaded\"><span class=\"token keyword\">interface</span> <span class=\"token class-name\">IPaginationRes<span class=\"token operator\">&lt;</span>TItem <span class=\"token operator\">=</span> <span class=\"token builtin\">unknown</span><span class=\"token operator\">&gt;</span></span> <span class=\"token punctuation\">{</span>\n  data<span class=\"token operator\">:</span> TItem<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n  page<span class=\"token operator\">:</span> <span class=\"token builtin\">number</span><span class=\"token punctuation\">;</span>\n  totalCount<span class=\"token operator\">:</span> <span class=\"token builtin\">number</span><span class=\"token punctuation\">;</span>\n  hasNextPage<span class=\"token operator\">:</span> <span class=\"token builtin\">boolean</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">function</span> <span class=\"token function\">fetchUserProfileList</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token builtin\">Promise</span><span class=\"token operator\">&lt;</span>IRes<span class=\"token operator\">&lt;</span>IPaginationRes<span class=\"token operator\">&lt;</span>IUserProfileRes<span class=\"token operator\">&gt;&gt;&gt;</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n</code><button class=\"copy-code-button\">复制</button></pre>\n<p>有这么一个函数，它可以接受多个类型的参数并进行对应处理，比如：</p>\n<ul>\n<li>对于字符串，返回部分截取；</li>\n<li>对于数字，返回它的 n 倍；</li>\n<li>对于对象，修改它的属性并返回。</li>\n</ul>\n<pre class=\"language-ts\" tabindex=\"0\"><code class=\"language-ts is-loaded\"><span class=\"token keyword\">function</span> <span class=\"token function\">handle</span><span class=\"token punctuation\">(</span>input<span class=\"token operator\">:</span> <span class=\"token builtin\">string</span> <span class=\"token operator\">|</span> <span class=\"token builtin\">number</span> <span class=\"token operator\">|</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token builtin\">string</span> <span class=\"token operator\">|</span> <span class=\"token builtin\">number</span> <span class=\"token operator\">|</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">const</span> shouldBeString <span class=\"token operator\">=</span> <span class=\"token function\">handle</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"linbudu\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> shouldBeNumber <span class=\"token operator\">=</span> <span class=\"token function\">handle</span><span class=\"token punctuation\">(</span><span class=\"token number\">599</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> shouldBeObject <span class=\"token operator\">=</span> <span class=\"token function\">handle</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span> name<span class=\"token operator\">:</span> <span class=\"token string\">\"linbudu\"</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code><button class=\"copy-code-button\">复制</button></pre>\n<p>虽然我们约束了入参的类型，但返回值的类型并没有像我们预期的那样和入参关联起来，上面三个调用结果的类型仍然是一个宽泛的联合类型 string | number | {}。难道要用重载一个个声明可能的关联关系？</p>\n<pre class=\"language-ts\" tabindex=\"0\"><code class=\"language-ts is-loaded\"><span class=\"token keyword\">function</span> <span class=\"token function\">handle</span><span class=\"token punctuation\">(</span>input<span class=\"token operator\">:</span> <span class=\"token builtin\">string</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token builtin\">string</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">handle</span><span class=\"token punctuation\">(</span>input<span class=\"token operator\">:</span> <span class=\"token builtin\">number</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token builtin\">number</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">handle</span><span class=\"token punctuation\">(</span>input<span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">handle</span><span class=\"token punctuation\">(</span>input<span class=\"token operator\">:</span> <span class=\"token builtin\">string</span> <span class=\"token operator\">|</span> <span class=\"token builtin\">number</span> <span class=\"token operator\">|</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token builtin\">string</span> <span class=\"token operator\">|</span> <span class=\"token builtin\">number</span> <span class=\"token operator\">|</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span> <span class=\"token punctuation\">{</span> <span class=\"token punctuation\">}</span>\n</code><button class=\"copy-code-button\">复制</button></pre>\n<p>这个时候，我们就该请出泛型</p>\n<pre class=\"language-ts\" tabindex=\"0\"><code class=\"language-ts is-loaded\"><span class=\"token keyword\">function</span> <span class=\"token generic-function\"><span class=\"token function\">handle</span><span class=\"token generic class-name\"><span class=\"token operator\">&lt;</span><span class=\"token constant\">T</span><span class=\"token operator\">&gt;</span></span></span><span class=\"token punctuation\">(</span>input<span class=\"token operator\">:</span> <span class=\"token constant\">T</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token constant\">T</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n</code><button class=\"copy-code-button\">复制</button></pre>\n<p>在这个函数接收到参数时，T 会自动地被填充为这个参数的类型。这也就意味着你不再需要预先确定参数的可能类型了，而在返回值与参数类型关联的情况下，也可以通过泛型参数来进行运算。</p>\n<pre class=\"language-ts\" tabindex=\"0\"><code class=\"language-ts is-loaded\"><span class=\"token keyword\">function</span> <span class=\"token generic-function\"><span class=\"token function\">swap</span><span class=\"token generic class-name\"><span class=\"token operator\">&lt;</span><span class=\"token constant\">T</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">U</span><span class=\"token operator\">&gt;</span></span></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span>start<span class=\"token punctuation\">,</span> end<span class=\"token punctuation\">]</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span><span class=\"token constant\">T</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">U</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span><span class=\"token constant\">U</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">T</span><span class=\"token punctuation\">]</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> <span class=\"token punctuation\">[</span>end<span class=\"token punctuation\">,</span> start<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">const</span> swapped1 <span class=\"token operator\">=</span> <span class=\"token function\">swap</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span><span class=\"token string\">\"linbudu\"</span><span class=\"token punctuation\">,</span> <span class=\"token number\">599</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> swapped2 <span class=\"token operator\">=</span> <span class=\"token function\">swap</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span><span class=\"token keyword\">null</span><span class=\"token punctuation\">,</span> <span class=\"token number\">599</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> swapped3 <span class=\"token operator\">=</span> <span class=\"token function\">swap</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">{</span> name<span class=\"token operator\">:</span> <span class=\"token string\">\"linbudu\"</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code><button class=\"copy-code-button\">复制</button></pre>\n<pre class=\"language-ts\" tabindex=\"0\"><code class=\"language-ts is-loaded\"><span class=\"token generic-function\"><span class=\"token function\">pick</span><span class=\"token generic class-name\"><span class=\"token operator\">&lt;</span><span class=\"token constant\">T</span> <span class=\"token keyword\">extends</span> object<span class=\"token punctuation\">,</span> <span class=\"token constant\">U</span> <span class=\"token keyword\">extends</span> <span class=\"token keyword\">keyof</span> <span class=\"token constant\">T</span><span class=\"token operator\">&gt;</span></span></span><span class=\"token punctuation\">(</span>object<span class=\"token operator\">:</span> <span class=\"token constant\">T</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">...</span>props<span class=\"token operator\">:</span> <span class=\"token builtin\">Array</span><span class=\"token operator\">&lt;</span><span class=\"token constant\">U</span><span class=\"token operator\">&gt;</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> Pick<span class=\"token operator\">&lt;</span><span class=\"token constant\">T</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">U</span><span class=\"token operator\">&gt;</span><span class=\"token punctuation\">;</span>\n</code><button class=\"copy-code-button\">复制</button></pre>\n<p>箭头函数的泛型</p>\n<pre class=\"language-ts\" tabindex=\"0\"><code class=\"language-ts is-loaded\"><span class=\"token keyword\">const</span> handle <span class=\"token operator\">=</span> <span class=\"token operator\">&lt;</span><span class=\"token constant\">T</span><span class=\"token operator\">&gt;</span><span class=\"token punctuation\">(</span>input<span class=\"token operator\">:</span> <span class=\"token constant\">T</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token constant\">T</span> <span class=\"token operator\">=&gt;</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n</code><button class=\"copy-code-button\">复制</button></pre>\n<p>在 tsx 文件中泛型的尖括号可能会造成报错，编译器无法识别这是一个组件还是一个泛型，此时你可以让它长得更像泛型一些</p>\n<pre class=\"language-ts\" tabindex=\"0\"><code class=\"language-ts is-loaded\"><span class=\"token keyword\">const</span> handle <span class=\"token operator\">=</span> <span class=\"token operator\">&lt;</span><span class=\"token constant\">T</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\"><span class=\"token builtin\">any</span></span><span class=\"token operator\">&gt;</span><span class=\"token punctuation\">(</span>input<span class=\"token operator\">:</span> <span class=\"token constant\">T</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token constant\">T</span> <span class=\"token operator\">=&gt;</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n</code><button class=\"copy-code-button\">复制</button></pre>\n<p>内置方法中的泛型</p>\n<p>Promise</p>\n<pre class=\"language-ts\" tabindex=\"0\"><code class=\"language-ts is-loaded\"><span class=\"token keyword\">function</span> <span class=\"token function\">p</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\"><span class=\"token builtin\">Promise</span><span class=\"token operator\">&lt;</span><span class=\"token builtin\">boolean</span><span class=\"token operator\">&gt;</span></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>resolve<span class=\"token punctuation\">,</span> reject<span class=\"token punctuation\">)</span> <span class=\"token operator\">=&gt;</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">resolve</span><span class=\"token punctuation\">(</span><span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code><button class=\"copy-code-button\">复制</button></pre>\n<p>在 TypeScript 内部的 Promise 类型声明中同样是通过泛型实现</p>\n<pre class=\"language-ts\" tabindex=\"0\"><code class=\"language-ts is-loaded\"><span class=\"token keyword\">interface</span> <span class=\"token class-name\">PromiseConstructor</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token generic-function\"><span class=\"token function\">resolve</span><span class=\"token generic class-name\"><span class=\"token operator\">&lt;</span><span class=\"token constant\">T</span><span class=\"token operator\">&gt;</span></span></span><span class=\"token punctuation\">(</span>value<span class=\"token operator\">:</span> <span class=\"token constant\">T</span> <span class=\"token operator\">|</span> PromiseLike<span class=\"token operator\">&lt;</span><span class=\"token constant\">T</span><span class=\"token operator\">&gt;</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token builtin\">Promise</span><span class=\"token operator\">&lt;</span><span class=\"token constant\">T</span><span class=\"token operator\">&gt;</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">declare</span> <span class=\"token keyword\">var</span> <span class=\"token builtin\">Promise</span><span class=\"token operator\">:</span> PromiseConstructor<span class=\"token punctuation\">;</span>\n</code><button class=\"copy-code-button\">复制</button></pre>\n<p>数组 Array</p>\n<pre class=\"language-ts\" tabindex=\"0\"><code class=\"language-ts is-loaded\"><span class=\"token keyword\">const</span> arr<span class=\"token operator\">:</span> <span class=\"token builtin\">Array</span><span class=\"token operator\">&lt;</span><span class=\"token builtin\">number</span><span class=\"token operator\">&gt;</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// 类型“string”的参数不能赋给类型“number”的参数。</span>\narr<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span><span class=\"token string\">'linbudu'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">// 类型“string”的参数不能赋给类型“number”的参数。</span>\narr<span class=\"token punctuation\">.</span><span class=\"token function\">includes</span><span class=\"token punctuation\">(</span><span class=\"token string\">'linbudu'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// number | undefined</span>\narr<span class=\"token punctuation\">.</span><span class=\"token function\">find</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=&gt;</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// 第一种 reduce</span>\narr<span class=\"token punctuation\">.</span><span class=\"token function\">reduce</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>prev<span class=\"token punctuation\">,</span> curr<span class=\"token punctuation\">,</span> idx<span class=\"token punctuation\">,</span> arr<span class=\"token punctuation\">)</span> <span class=\"token operator\">=&gt;</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> prev<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// 第二种 reduce</span>\n<span class=\"token comment\">// 报错：不能将 number 类型的值赋值给 never 类型</span>\narr<span class=\"token punctuation\">.</span><span class=\"token function\">reduce</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>prev<span class=\"token punctuation\">,</span> curr<span class=\"token punctuation\">,</span> idx<span class=\"token punctuation\">,</span> arr<span class=\"token punctuation\">)</span> <span class=\"token operator\">=&gt;</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> <span class=\"token punctuation\">[</span><span class=\"token operator\">...</span>prev<span class=\"token punctuation\">,</span> curr<span class=\"token punctuation\">]</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code><button class=\"copy-code-button\">复制</button></pre>\n<p>reduce 方法是相对特殊的一个，它的类型声明存在几种不同的重载：</p>\n<ul>\n<li>当你不传入初始值时，泛型参数会从数组的元素类型中进行填充。</li>\n<li>当你传入初始值时，如果初始值的类型与数组元素类型一致，则使用数组的元素类型进行填充。即这里第一个 reduce 调用。</li>\n<li>当你传入一个数组类型的初始值，比如这里的第二个 reduce 调用，reduce 的泛型参数会默认从这个初始值推导出的类型进行填充，如这里是 never[]。</li>\n</ul>\n<p>第三种情况也就意味着信息不足，无法推导出正确的类型，我们可以手动传入泛型参数来解决</p>\n<pre class=\"language-ts\" tabindex=\"0\"><code class=\"language-ts is-loaded\">arr<span class=\"token punctuation\">.</span><span class=\"token generic-function\"><span class=\"token function\">reduce</span><span class=\"token generic class-name\"><span class=\"token operator\">&lt;</span><span class=\"token builtin\">number</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token operator\">&gt;</span></span></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>prev<span class=\"token punctuation\">,</span> curr<span class=\"token punctuation\">,</span> idx<span class=\"token punctuation\">,</span> arr<span class=\"token punctuation\">)</span> <span class=\"token operator\">=&gt;</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> prev<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code><button class=\"copy-code-button\">复制</button></pre>\n<p>React</p>\n<pre class=\"language-ts\" tabindex=\"0\"><code class=\"language-ts is-loaded\"><span class=\"token keyword\">const</span> <span class=\"token punctuation\">[</span>state<span class=\"token punctuation\">,</span> setState<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token generic-function\"><span class=\"token function\">useState</span><span class=\"token generic class-name\"><span class=\"token operator\">&lt;</span><span class=\"token builtin\">number</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token operator\">&gt;</span></span></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">// 不传入默认值，则类型为 number[] | undefined</span>\n<span class=\"token keyword\">const</span> <span class=\"token punctuation\">[</span>state<span class=\"token punctuation\">,</span> setState<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token generic-function\"><span class=\"token function\">useState</span><span class=\"token generic class-name\"><span class=\"token operator\">&lt;</span><span class=\"token builtin\">number</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token operator\">&gt;</span></span></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// 体现在 ref.current 上</span>\n<span class=\"token keyword\">const</span> ref <span class=\"token operator\">=</span> <span class=\"token generic-function\"><span class=\"token function\">useRef</span><span class=\"token generic class-name\"><span class=\"token operator\">&lt;</span><span class=\"token builtin\">number</span><span class=\"token operator\">&gt;</span></span></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">const</span> context <span class=\"token operator\">=</span>  <span class=\"token generic-function\"><span class=\"token function\">createContext</span><span class=\"token generic class-name\"><span class=\"token operator\">&lt;</span>ContextType<span class=\"token operator\">&gt;</span></span></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code><button class=\"copy-code-button\">复制</button></pre>",
      "tags": [
        "泛型"
      ],
      "createTime": 1665883826828,
      "updateTime": 1665886180160,
      "uuid": "7cc2a9ba-976e-42e2-a469-77dbb90a5885",
      "isCreated": true
    },
    {
      "content": "TypeScript 中提供了非常强大的类型推导能力，它会随着你的代码逻辑不断尝试收窄类型，这一能力称之为类型的控制流分析（也可以简单理解为类型推导）。\n\n```ts\nfunction foo (input: string | number) {\n  if(typeof input === 'string') {}\n  if(typeof input === 'number') {}\n  // ...\n}\n```\n\n我们从逻辑中进行类型地推导，再反过来让类型为逻辑保驾护航。\n\nif 条件中的表达式要是现在被提取出来了\n\n```ts\nfunction isString(input: unknown): boolean {\n  return typeof input === \"string\";\n}\n\nfunction foo(input: string | number) {\n  if (isString(input)) {\n    // 类型“string | number”上不存在属性“replace”。\n    (input).replace(\"linbudu\", \"linbudu599\")\n  }\n  if (typeof input === 'number') { }\n  // ...\n}\n```\n\nTypeScript 引入了 is 关键字来显式地提供类型信息\n\n```ts\nfunction isString(input: unknown): input is string {\n  return typeof input === \"string\";\n}\n\nfunction foo(input: string | number) {\n  if (isString(input)) {\n    // 正确了\n    (input).replace(\"linbudu\", \"linbudu599\")\n  }\n  if (typeof input === 'number') { }\n  // ...\n}\n```\n\n在它的返回值中，我们不再使用 boolean 作为类型标注，而是使用 `input is string`。\n\n除了使用简单的原始类型以外，我们还可以在类型守卫中使用对象类型、联合类型等\n\n```ts\nexport type Falsy = false | \"\" | 0 | null | undefined;\n\nexport const isFalsy = (val: unknown): val is Falsy => !val;\n\n// 不包括不常用的 symbol 和 bigint\nexport type Primitive = string | number | boolean | undefined;\n\nexport const isPrimitive = (val: unknown): val is Primitive => ['string', 'number', 'boolean' , 'undefined'].includes(typeof val);\n```\n\n基于 in 与 instanceof 的类型保护\n\n```ts\ninterface Foo {\n  foo: string;\n  fooOnly: boolean;\n  shared: number;\n}\n\ninterface Bar {\n  bar: string;\n  barOnly: boolean;\n  shared: number;\n}\n\nfunction handle(input: Foo | Bar) {\n  if ('foo' in input) {\n    input.fooOnly;\n  } else {\n    input.barOnly;\n  }\n}\n```\n\n可辨识属性可以是结构层面的，比如结构 A 的属性 prop 是数组，而结构 B 的属性 prop 是对象，或者结构 A 中存在属性 prop 而结构 B 中不存在。它甚至可以是共同属性的字面量类型差异。\n\n```ts\nfunction ensureArray(input: number | number[]): number[] {\n  if (Array.isArray(input)) {\n    return input;\n  } else {\n    return [input];\n  }\n}\n\ninterface Foo {\n  kind: 'foo';\n  diffType: string;\n  fooOnly: boolean;\n  shared: number;\n}\n\ninterface Bar {\n  kind: 'bar';\n  diffType: number;\n  barOnly: boolean;\n  shared: number;\n}\n\nfunction handle1(input: Foo | Bar) {\n  if (input.kind === 'foo') {\n    input.fooOnly;\n  } else {\n    input.barOnly;\n  }\n}\n```\n\n同样的，instanceof 也可以用来进行类型保护\n\n```ts\nclass FooBase {}\n\nclass BarBase {}\n\nclass Foo extends FooBase {\n  fooOnly() {}\n}\nclass Bar extends BarBase {\n  barOnly() {}\n}\n\nfunction handle(input: Foo | Bar) {\n  if (input instanceof FooBase) {\n    input.fooOnly();\n  } else {\n    input.barOnly();\n  }\n}\n```\n\n类型断言守卫\n\n```ts\nimport assert from 'assert';\n\nlet name: any = 'linbudu';\n\nassert(typeof name === 'number');\n\n// number 类型\nname.toFixed();\n```\n\nTypeScript 3.7 版本专门引入了 asserts 关键字来进行断言场景下的类型守卫\n\n```ts\nfunction assert(condition: any, msg?: string): asserts condition {\n  if (!condition) {\n    throw new Error(msg);\n  }\n}\n```\n\ncondition 甚至还可以结合使用 is 关键字来提供进一步的类型守卫能力\n\n```ts\nlet name: any = 'linbudu';\n\nfunction assertIsNumber(val: any): asserts val is number {\n  if (typeof val !== 'number') {\n    throw new Error('Not a number!');\n  }\n}\n\nassertIsNumber(name);\n\n// number 类型！\nname.toFixed();\n```\n\n下面这个例子在此前（4.6 版本以前）的 TypeScript 代码中会报错：\n\n```ts\ntype Args = ['a', number] | ['b', string];\n\ntype Func = (...args: [\"a\", number] | [\"b\", string]) => void;\n\nconst f1: Func = (kind, payload) => {\n  if (kind === \"a\") {\n    // 仍然是 string | number\n    payload.toFixed();\n  }\n  if (kind === \"b\") {\n    // 仍然是 string | number\n    payload.toUpperCase();\n  }\n};\n```\n\n在 4.6 版本中则对这一情况下的 联合类型辨识（即元组） 做了支持。\n",
      "preview": "<p>TypeScript 中提供了非常强大的类型推导能力，它会随着你的代码逻辑不断尝试收窄类型，这一能力称之为类型的控制流分析（也可以简单理解为类型推导）。</p>\n<pre class=\"language-ts\" tabindex=\"0\"><code class=\"language-ts is-loaded\"><span class=\"token keyword\">function</span> <span class=\"token function\">foo</span> <span class=\"token punctuation\">(</span>input<span class=\"token operator\">:</span> <span class=\"token builtin\">string</span> <span class=\"token operator\">|</span> <span class=\"token builtin\">number</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">typeof</span> input <span class=\"token operator\">===</span> <span class=\"token string\">'string'</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n  <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">typeof</span> input <span class=\"token operator\">===</span> <span class=\"token string\">'number'</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n  <span class=\"token comment\">// ...</span>\n<span class=\"token punctuation\">}</span>\n</code><button class=\"copy-code-button\">复制</button></pre>\n<p>我们从逻辑中进行类型地推导，再反过来让类型为逻辑保驾护航。</p>\n<p>if 条件中的表达式要是现在被提取出来了</p>\n<pre class=\"language-ts\" tabindex=\"0\"><code class=\"language-ts is-loaded\"><span class=\"token keyword\">function</span> <span class=\"token function\">isString</span><span class=\"token punctuation\">(</span>input<span class=\"token operator\">:</span> <span class=\"token builtin\">unknown</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token builtin\">boolean</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> <span class=\"token keyword\">typeof</span> input <span class=\"token operator\">===</span> <span class=\"token string\">\"string\"</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">function</span> <span class=\"token function\">foo</span><span class=\"token punctuation\">(</span>input<span class=\"token operator\">:</span> <span class=\"token builtin\">string</span> <span class=\"token operator\">|</span> <span class=\"token builtin\">number</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">isString</span><span class=\"token punctuation\">(</span>input<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// 类型“string | number”上不存在属性“replace”。</span>\n    <span class=\"token punctuation\">(</span>input<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">replace</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"linbudu\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"linbudu599\"</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">typeof</span> input <span class=\"token operator\">===</span> <span class=\"token string\">'number'</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> <span class=\"token punctuation\">}</span>\n  <span class=\"token comment\">// ...</span>\n<span class=\"token punctuation\">}</span>\n</code><button class=\"copy-code-button\">复制</button></pre>\n<p>TypeScript 引入了 is 关键字来显式地提供类型信息</p>\n<pre class=\"language-ts\" tabindex=\"0\"><code class=\"language-ts is-loaded\"><span class=\"token keyword\">function</span> <span class=\"token function\">isString</span><span class=\"token punctuation\">(</span>input<span class=\"token operator\">:</span> <span class=\"token builtin\">unknown</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> input <span class=\"token keyword\">is</span> <span class=\"token builtin\">string</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> <span class=\"token keyword\">typeof</span> input <span class=\"token operator\">===</span> <span class=\"token string\">\"string\"</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">function</span> <span class=\"token function\">foo</span><span class=\"token punctuation\">(</span>input<span class=\"token operator\">:</span> <span class=\"token builtin\">string</span> <span class=\"token operator\">|</span> <span class=\"token builtin\">number</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">isString</span><span class=\"token punctuation\">(</span>input<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// 正确了</span>\n    <span class=\"token punctuation\">(</span>input<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">replace</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"linbudu\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"linbudu599\"</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">typeof</span> input <span class=\"token operator\">===</span> <span class=\"token string\">'number'</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> <span class=\"token punctuation\">}</span>\n  <span class=\"token comment\">// ...</span>\n<span class=\"token punctuation\">}</span>\n</code><button class=\"copy-code-button\">复制</button></pre>\n<p>在它的返回值中，我们不再使用 boolean 作为类型标注，而是使用 <code>input is string</code>。</p>\n<p>除了使用简单的原始类型以外，我们还可以在类型守卫中使用对象类型、联合类型等</p>\n<pre class=\"language-ts\" tabindex=\"0\"><code class=\"language-ts is-loaded\"><span class=\"token keyword\">export</span> <span class=\"token keyword\">type</span> <span class=\"token class-name\">Falsy</span> <span class=\"token operator\">=</span> <span class=\"token boolean\">false</span> <span class=\"token operator\">|</span> <span class=\"token string\">\"\"</span> <span class=\"token operator\">|</span> <span class=\"token number\">0</span> <span class=\"token operator\">|</span> <span class=\"token keyword\">null</span> <span class=\"token operator\">|</span> <span class=\"token keyword\">undefined</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">const</span> isFalsy <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>val<span class=\"token operator\">:</span> <span class=\"token builtin\">unknown</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> val <span class=\"token keyword\">is</span> Falsy <span class=\"token operator\">=&gt;</span> <span class=\"token operator\">!</span>val<span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// 不包括不常用的 symbol 和 bigint</span>\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">type</span> <span class=\"token class-name\">Primitive</span> <span class=\"token operator\">=</span> <span class=\"token builtin\">string</span> <span class=\"token operator\">|</span> <span class=\"token builtin\">number</span> <span class=\"token operator\">|</span> <span class=\"token builtin\">boolean</span> <span class=\"token operator\">|</span> <span class=\"token keyword\">undefined</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">const</span> isPrimitive <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>val<span class=\"token operator\">:</span> <span class=\"token builtin\">unknown</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> val <span class=\"token keyword\">is</span> Primitive <span class=\"token operator\">=&gt;</span> <span class=\"token punctuation\">[</span><span class=\"token string\">'string'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'number'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'boolean'</span> <span class=\"token punctuation\">,</span> <span class=\"token string\">'undefined'</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span><span class=\"token function\">includes</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">typeof</span> val<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code><button class=\"copy-code-button\">复制</button></pre>\n<p>基于 in 与 instanceof 的类型保护</p>\n<pre class=\"language-ts\" tabindex=\"0\"><code class=\"language-ts is-loaded\"><span class=\"token keyword\">interface</span> <span class=\"token class-name\">Foo</span> <span class=\"token punctuation\">{</span>\n  foo<span class=\"token operator\">:</span> <span class=\"token builtin\">string</span><span class=\"token punctuation\">;</span>\n  fooOnly<span class=\"token operator\">:</span> <span class=\"token builtin\">boolean</span><span class=\"token punctuation\">;</span>\n  shared<span class=\"token operator\">:</span> <span class=\"token builtin\">number</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">interface</span> <span class=\"token class-name\">Bar</span> <span class=\"token punctuation\">{</span>\n  bar<span class=\"token operator\">:</span> <span class=\"token builtin\">string</span><span class=\"token punctuation\">;</span>\n  barOnly<span class=\"token operator\">:</span> <span class=\"token builtin\">boolean</span><span class=\"token punctuation\">;</span>\n  shared<span class=\"token operator\">:</span> <span class=\"token builtin\">number</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">function</span> <span class=\"token function\">handle</span><span class=\"token punctuation\">(</span>input<span class=\"token operator\">:</span> Foo <span class=\"token operator\">|</span> Bar<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token string\">'foo'</span> <span class=\"token keyword\">in</span> input<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    input<span class=\"token punctuation\">.</span>fooOnly<span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n    input<span class=\"token punctuation\">.</span>barOnly<span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n</code><button class=\"copy-code-button\">复制</button></pre>\n<p>可辨识属性可以是结构层面的，比如结构 A 的属性 prop 是数组，而结构 B 的属性 prop 是对象，或者结构 A 中存在属性 prop 而结构 B 中不存在。它甚至可以是共同属性的字面量类型差异。</p>\n<pre class=\"language-ts\" tabindex=\"0\"><code class=\"language-ts is-loaded\"><span class=\"token keyword\">function</span> <span class=\"token function\">ensureArray</span><span class=\"token punctuation\">(</span>input<span class=\"token operator\">:</span> <span class=\"token builtin\">number</span> <span class=\"token operator\">|</span> <span class=\"token builtin\">number</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token builtin\">number</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token builtin\">Array</span><span class=\"token punctuation\">.</span><span class=\"token function\">isArray</span><span class=\"token punctuation\">(</span>input<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> input<span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token punctuation\">[</span>input<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">interface</span> <span class=\"token class-name\">Foo</span> <span class=\"token punctuation\">{</span>\n  kind<span class=\"token operator\">:</span> <span class=\"token string\">'foo'</span><span class=\"token punctuation\">;</span>\n  diffType<span class=\"token operator\">:</span> <span class=\"token builtin\">string</span><span class=\"token punctuation\">;</span>\n  fooOnly<span class=\"token operator\">:</span> <span class=\"token builtin\">boolean</span><span class=\"token punctuation\">;</span>\n  shared<span class=\"token operator\">:</span> <span class=\"token builtin\">number</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">interface</span> <span class=\"token class-name\">Bar</span> <span class=\"token punctuation\">{</span>\n  kind<span class=\"token operator\">:</span> <span class=\"token string\">'bar'</span><span class=\"token punctuation\">;</span>\n  diffType<span class=\"token operator\">:</span> <span class=\"token builtin\">number</span><span class=\"token punctuation\">;</span>\n  barOnly<span class=\"token operator\">:</span> <span class=\"token builtin\">boolean</span><span class=\"token punctuation\">;</span>\n  shared<span class=\"token operator\">:</span> <span class=\"token builtin\">number</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">function</span> <span class=\"token function\">handle1</span><span class=\"token punctuation\">(</span>input<span class=\"token operator\">:</span> Foo <span class=\"token operator\">|</span> Bar<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>input<span class=\"token punctuation\">.</span>kind <span class=\"token operator\">===</span> <span class=\"token string\">'foo'</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    input<span class=\"token punctuation\">.</span>fooOnly<span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n    input<span class=\"token punctuation\">.</span>barOnly<span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n</code><button class=\"copy-code-button\">复制</button></pre>\n<p>同样的，instanceof 也可以用来进行类型保护</p>\n<pre class=\"language-ts\" tabindex=\"0\"><code class=\"language-ts is-loaded\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">FooBase</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">BarBase</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">Foo</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">FooBase</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">fooOnly</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">Bar</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">BarBase</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">barOnly</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">function</span> <span class=\"token function\">handle</span><span class=\"token punctuation\">(</span>input<span class=\"token operator\">:</span> Foo <span class=\"token operator\">|</span> Bar<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>input <span class=\"token keyword\">instanceof</span> <span class=\"token class-name\">FooBase</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    input<span class=\"token punctuation\">.</span><span class=\"token function\">fooOnly</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n    input<span class=\"token punctuation\">.</span><span class=\"token function\">barOnly</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n</code><button class=\"copy-code-button\">复制</button></pre>\n<p>类型断言守卫</p>\n<pre class=\"language-ts\" tabindex=\"0\"><code class=\"language-ts is-loaded\"><span class=\"token keyword\">import</span> assert <span class=\"token keyword\">from</span> <span class=\"token string\">'assert'</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">let</span> name<span class=\"token operator\">:</span> <span class=\"token builtin\">any</span> <span class=\"token operator\">=</span> <span class=\"token string\">'linbudu'</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token function\">assert</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">typeof</span> name <span class=\"token operator\">===</span> <span class=\"token string\">'number'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// number 类型</span>\nname<span class=\"token punctuation\">.</span><span class=\"token function\">toFixed</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code><button class=\"copy-code-button\">复制</button></pre>\n<p>TypeScript 3.7 版本专门引入了 asserts 关键字来进行断言场景下的类型守卫</p>\n<pre class=\"language-ts\" tabindex=\"0\"><code class=\"language-ts is-loaded\"><span class=\"token keyword\">function</span> <span class=\"token function\">assert</span><span class=\"token punctuation\">(</span>condition<span class=\"token operator\">:</span> <span class=\"token builtin\">any</span><span class=\"token punctuation\">,</span> msg<span class=\"token operator\">?</span><span class=\"token operator\">:</span> <span class=\"token builtin\">string</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token keyword\">asserts</span> condition <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>condition<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">throw</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Error</span><span class=\"token punctuation\">(</span>msg<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n</code><button class=\"copy-code-button\">复制</button></pre>\n<p>condition 甚至还可以结合使用 is 关键字来提供进一步的类型守卫能力</p>\n<pre class=\"language-ts\" tabindex=\"0\"><code class=\"language-ts is-loaded\"><span class=\"token keyword\">let</span> name<span class=\"token operator\">:</span> <span class=\"token builtin\">any</span> <span class=\"token operator\">=</span> <span class=\"token string\">'linbudu'</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">function</span> <span class=\"token function\">assertIsNumber</span><span class=\"token punctuation\">(</span>val<span class=\"token operator\">:</span> <span class=\"token builtin\">any</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token keyword\">asserts</span> val <span class=\"token keyword\">is</span> <span class=\"token builtin\">number</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">typeof</span> val <span class=\"token operator\">!==</span> <span class=\"token string\">'number'</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">throw</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Error</span><span class=\"token punctuation\">(</span><span class=\"token string\">'Not a number!'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token function\">assertIsNumber</span><span class=\"token punctuation\">(</span>name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// number 类型！</span>\nname<span class=\"token punctuation\">.</span><span class=\"token function\">toFixed</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code><button class=\"copy-code-button\">复制</button></pre>\n<p>下面这个例子在此前（4.6 版本以前）的 TypeScript 代码中会报错：</p>\n<pre class=\"language-ts\" tabindex=\"0\"><code class=\"language-ts is-loaded\"><span class=\"token keyword\">type</span> <span class=\"token class-name\">Args</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token string\">'a'</span><span class=\"token punctuation\">,</span> <span class=\"token builtin\">number</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">|</span> <span class=\"token punctuation\">[</span><span class=\"token string\">'b'</span><span class=\"token punctuation\">,</span> <span class=\"token builtin\">string</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">type</span> <span class=\"token class-name\">Func</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">...</span>args<span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span><span class=\"token string\">\"a\"</span><span class=\"token punctuation\">,</span> <span class=\"token builtin\">number</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">|</span> <span class=\"token punctuation\">[</span><span class=\"token string\">\"b\"</span><span class=\"token punctuation\">,</span> <span class=\"token builtin\">string</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=&gt;</span> <span class=\"token keyword\">void</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">const</span> f1<span class=\"token operator\">:</span> <span class=\"token function-variable function\">Func</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>kind<span class=\"token punctuation\">,</span> payload<span class=\"token punctuation\">)</span> <span class=\"token operator\">=&gt;</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>kind <span class=\"token operator\">===</span> <span class=\"token string\">\"a\"</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// 仍然是 string | number</span>\n    payload<span class=\"token punctuation\">.</span><span class=\"token function\">toFixed</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>kind <span class=\"token operator\">===</span> <span class=\"token string\">\"b\"</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// 仍然是 string | number</span>\n    payload<span class=\"token punctuation\">.</span><span class=\"token function\">toUpperCase</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n</code><button class=\"copy-code-button\">复制</button></pre>\n<p>在 4.6 版本中则对这一情况下的 联合类型辨识（即元组） 做了支持。</p>",
      "tags": [
        "类型守卫"
      ],
      "createTime": 1665849747288,
      "updateTime": 1665849771775,
      "uuid": "830f3b0a-385d-4a6c-9111-489df9742920",
      "isCreated": true
    },
    {
      "content": "TypeScript 新增了用于类型查询的 typeof ，即 Type Query Operator，这个 typeof 返回的是一个 TypeScript 类型\n\n```ts\nconst str = \"linbudu\";\n\nconst obj = { name: \"linbudu\" };\n\nconst nullVar = null;\nconst undefinedVar = undefined;\n\nconst func = (input: string) => {\n  return input.length > 10;\n}\n\ntype Str = typeof str; // \"linbudu\"\ntype Obj = typeof obj; // { name: string; }\ntype Null = typeof nullVar; // null\ntype Undefined = typeof undefined; // undefined\ntype Func = typeof func; // (input: string) => boolean\n```\n\n不仅可以直接在类型标注中使用 typeof，还能在工具类型中使用 typeof\n\n```ts\nconst func = (input: string) => {\n  return input.length > 10;\n}\n\nconst func2: typeof func = (name: string) => {\n  return name === 'linbudu'\n}\n```\n\n```ts\nconst func = (input: string) => {\n  return input.length > 10;\n}\n\n// boolean\ntype FuncReturnType = ReturnType<typeof func>;\n```\n\ntypeof 返回的类型就是当你把鼠标悬浮在变量名上时出现的推导后的类型，并且是最窄的推导程度（即到字面量类型的级别）。\n\n在逻辑代码中使用的 typeof 一定会是 JavaScript 中的 typeof，而类型代码（如类型标注、类型别名中等）中的一定是类型查询的 typeof 。\n\n为了更好地避免这种情况，也就是隔离类型层和逻辑层，类型查询操作符后是不允许使用表达式的\n\n```ts\nconst isInputValid = (input: string) => {\n  return input.length > 10;\n}\n\n// 不允许表达式\nlet isValid: typeof isInputValid(\"linbudu\");\n```\n\n",
      "preview": "<p>TypeScript 新增了用于类型查询的 typeof ，即 Type Query Operator，这个 typeof 返回的是一个 TypeScript 类型</p>\n<pre class=\"language-ts\" tabindex=\"0\"><code class=\"language-ts is-loaded\"><span class=\"token keyword\">const</span> str <span class=\"token operator\">=</span> <span class=\"token string\">\"linbudu\"</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">const</span> obj <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span> name<span class=\"token operator\">:</span> <span class=\"token string\">\"linbudu\"</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">const</span> nullVar <span class=\"token operator\">=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> undefinedVar <span class=\"token operator\">=</span> <span class=\"token keyword\">undefined</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">const</span> <span class=\"token function-variable function\">func</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>input<span class=\"token operator\">:</span> <span class=\"token builtin\">string</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=&gt;</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> input<span class=\"token punctuation\">.</span>length <span class=\"token operator\">&gt;</span> <span class=\"token number\">10</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">type</span> <span class=\"token class-name\">Str</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">typeof</span> str<span class=\"token punctuation\">;</span> <span class=\"token comment\">// \"linbudu\"</span>\n<span class=\"token keyword\">type</span> <span class=\"token class-name\">Obj</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">typeof</span> obj<span class=\"token punctuation\">;</span> <span class=\"token comment\">// { name: string; }</span>\n<span class=\"token keyword\">type</span> <span class=\"token class-name\">Null</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">typeof</span> nullVar<span class=\"token punctuation\">;</span> <span class=\"token comment\">// null</span>\n<span class=\"token keyword\">type</span> <span class=\"token class-name\">Undefined</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">typeof</span> <span class=\"token keyword\">undefined</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// undefined</span>\n<span class=\"token keyword\">type</span> <span class=\"token class-name\">Func</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">typeof</span> func<span class=\"token punctuation\">;</span> <span class=\"token comment\">// (input: string) =&gt; boolean</span>\n</code><button class=\"copy-code-button\">复制</button></pre>\n<p>不仅可以直接在类型标注中使用 typeof，还能在工具类型中使用 typeof</p>\n<pre class=\"language-ts\" tabindex=\"0\"><code class=\"language-ts is-loaded\"><span class=\"token keyword\">const</span> <span class=\"token function-variable function\">func</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>input<span class=\"token operator\">:</span> <span class=\"token builtin\">string</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=&gt;</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> input<span class=\"token punctuation\">.</span>length <span class=\"token operator\">&gt;</span> <span class=\"token number\">10</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">const</span> func2<span class=\"token operator\">:</span> <span class=\"token keyword\">typeof</span> <span class=\"token function-variable function\">func</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>name<span class=\"token operator\">:</span> <span class=\"token builtin\">string</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=&gt;</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> name <span class=\"token operator\">===</span> <span class=\"token string\">'linbudu'</span>\n<span class=\"token punctuation\">}</span>\n</code><button class=\"copy-code-button\">复制</button></pre>\n<pre class=\"language-ts\" tabindex=\"0\"><code class=\"language-ts is-loaded\"><span class=\"token keyword\">const</span> <span class=\"token function-variable function\">func</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>input<span class=\"token operator\">:</span> <span class=\"token builtin\">string</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=&gt;</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> input<span class=\"token punctuation\">.</span>length <span class=\"token operator\">&gt;</span> <span class=\"token number\">10</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\">// boolean</span>\n<span class=\"token keyword\">type</span> <span class=\"token class-name\">FuncReturnType</span> <span class=\"token operator\">=</span> ReturnType<span class=\"token operator\">&lt;</span><span class=\"token keyword\">typeof</span> func<span class=\"token operator\">&gt;</span><span class=\"token punctuation\">;</span>\n</code><button class=\"copy-code-button\">复制</button></pre>\n<p>typeof 返回的类型就是当你把鼠标悬浮在变量名上时出现的推导后的类型，并且是最窄的推导程度（即到字面量类型的级别）。</p>\n<p>在逻辑代码中使用的 typeof 一定会是 JavaScript 中的 typeof，而类型代码（如类型标注、类型别名中等）中的一定是类型查询的 typeof 。</p>\n<p>为了更好地避免这种情况，也就是隔离类型层和逻辑层，类型查询操作符后是不允许使用表达式的</p>\n<pre class=\"language-ts\" tabindex=\"0\"><code class=\"language-ts is-loaded\"><span class=\"token keyword\">const</span> <span class=\"token function-variable function\">isInputValid</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>input<span class=\"token operator\">:</span> <span class=\"token builtin\">string</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=&gt;</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> input<span class=\"token punctuation\">.</span>length <span class=\"token operator\">&gt;</span> <span class=\"token number\">10</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\">// 不允许表达式</span>\n<span class=\"token keyword\">let</span> isValid<span class=\"token operator\">:</span> <span class=\"token keyword\">typeof</span> <span class=\"token function\">isInputValid</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"linbudu\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code><button class=\"copy-code-button\">复制</button></pre>",
      "tags": [
        "类型查询"
      ],
      "createTime": 1665845554599,
      "updateTime": 1665845693973,
      "uuid": "47903e40-9474-4008-b36d-8134917a6727",
      "isCreated": true
    },
    {
      "content": "类型工具可以分成三类：操作符、关键字与专用语法。\n\n按照使用目的来划分，类型工具可以分为**类型创建**与**类型安全保护**两类。\n\n类型别名\n\n```ts\ntype StatusCode = 200 | 301 | 400 | 500 | 502;\ntype PossibleDataTypes = string | number | (() => unknown);\n\nconst status: StatusCode = 502;\n```\n\n```ts\ntype Handler = (e: Event) => void;\n\nconst clickHandler: Handler = (e) => { };\nconst moveHandler: Handler = (e) => { };\nconst dragHandler: Handler = (e) => { };\n```\n\n在类型别名中，类型别名可以这么声明自己能够接受泛型。一旦接受了泛型，我们就叫它工具类型：\n\n```ts\ntype Factory<T> = T | number | string;\n```\n\n我们一般不会直接使用工具类型来做类型标注，而是再度声明一个新的类型别名\n\n```ts\ntype FactoryWithBool = Factory<boolean>;\n\nconst foo: FactoryWithBool = true;\n```\n\n```ts\ntype MaybeNull<T> = T | null;\ntype MaybeArray<T> = T | T[];\n```\n\n类型别名中可以接受任意个泛型，以及为泛型指定约束、默认值。\n\n交叉类型，使用 `&`，需要符合这里的所有类型，才可以说实现了这个交叉类型，即 A & B，需要同时满足 A 与 B 两个类型才行。\n\n```ts\ninterface NameStruct {\n  name: string;\n}\n\ninterface AgeStruct {\n  age: number;\n}\n\ntype ProfileStruct = NameStruct & AgeStruct;\n\nconst profile: ProfileStruct = {\n  name: \"linbudu\",\n  age: 18\n}\n```\n\n```ts\ntype StrAndNum = string & number; // never\n```\n\n存在既是 string 又是 number 的类型吗？当然不。\n\n对于对象类型的交叉类型，其内部的同名属性类型同样会按照交叉类型进行合并\n\n```ts\ntype Struct1 = {\n  primitiveProp: string;\n  objectProp: {\n    name: string;\n  }\n}\n\ntype Struct2 = {\n  primitiveProp: number;\n  objectProp: {\n    age: number;\n  }\n}\n\ntype Composed = Struct1 & Struct2;\n\ntype PrimitivePropType = Composed['primitiveProp']; // never\ntype ObjectPropType = Composed['objectProp']; // { name: string; age: number; }\n```\n\n```ts\ntype UnionIntersection1 = (1 | 2 | 3) & (1 | 2); // 1 | 2\ntype UnionIntersection2 = (string | number | symbol) & string; // string\n```\n\n索引类型指的不是某一个特定的类型工具，它包含三个部分：索引签名类型、索引类型查询与索引类型访问。\n\n索引签名类型主要指的是在接口或类型别名中，通过以下语法来快速声明一个键值类型一致的类型结构：\n\n```ts\ninterface AllStringTypes {\n  [key: string]: string;\n}\n\ntype AllStringTypes = {\n  [key: string]: string;\n}\n```\n\n即使你还没声明具体的属性，对于这些类型结构的属性访问也将全部被视为 string 类型\n\n```ts\ninterface AllStringTypes {\n  [key: string]: string;\n}\n\ntype PropType1 = AllStringTypes['linbudu']; // string\ntype PropType2 = AllStringTypes['599']; // string\n```\n\n由于 JavaScript 中，对于 obj[prop] 形式的访问会将数字索引访问转换为字符串索引访问，也就是说， obj[599] 和 obj['599'] 的效果是一致的。因此，在字符串索引签名类型中我们仍然可以声明数字类型的键。类似的，symbol 类型也是如此\n\n```ts\nconst foo: AllStringTypes = {\n  \"linbudu\": \"599\",\n  599: \"linbudu\",\n  [Symbol(\"ddd\")]: 'symbol',\n}\n```\n\n索引签名类型也可以和具体的键值对类型声明并存，但这时这些具体的键值类型也需要符合索引签名类型的声明：\n\n```ts\ninterface StringOrBooleanTypes {\n  propA: number;\n  propB: boolean;\n  [key: string]: number | boolean;\n}\n```\n\nkeyof 操作符,可以将对象中的所有键转换为对应字面量类型，然后再组合成联合类型。\n\n```ts\ninterface Foo {\n  linbudu: 1,\n  599: 2\n}\n\ntype FooKeys = keyof Foo; // \"linbudu\" | 599\n```\n\n除了应用在已知的对象类型结构上以外，你还可以直接 keyof any 来生产一个联合类型，它会由所有可用作对象键值的类型组成：string | number | symbol。也就是说，它是由无数字面量类型组成的，由此我们可以知道， keyof 的产物必定是一个联合类型。\n\n类型查询\n\n```ts\ninterface NumberRecord {\n  [key: string]: number;\n}\n\ntype PropType = NumberRecord[string]; // number\n```\n\n```ts\ninterface Foo {\n  propA: number;\n  propB: boolean;\n}\n\ntype PropAType = Foo['propA']; // number\ntype PropBType = Foo['propB']; // boolean\n```\n\n```ts\ninterface Foo {\n  propA: number;\n  propB: boolean;\n  propC: string;\n}\n\ntype PropTypeUnion = Foo[keyof Foo]; // string | number | boolean\n```\n\n在未声明索引签名类型的情况下，我们不能使用 NumberRecord[string] 这种原始类型的访问方式，而只能通过键名的字面量类型来进行访问。\n\n```ts\ninterface Foo {\n  propA: number;\n}\n\n// 类型“Foo”没有匹配的类型“string”的索引签名。\ntype PropAType = Foo[string]; \n```\n\n映射类型指的就是一个确切的类型工具\n\n```ts\ntype Stringify<T> = {\n  [K in keyof T]: string;\n};\n```\n\n```ts\ntype Clone<T> = {\n  [K in keyof T]: T[K];\n};\n```\n\n\n\n",
      "preview": "<p>类型工具可以分成三类：操作符、关键字与专用语法。</p>\n<p>按照使用目的来划分，类型工具可以分为<strong>类型创建</strong>与<strong>类型安全保护</strong>两类。</p>\n<p>类型别名</p>\n<pre class=\"language-ts\" tabindex=\"0\"><code class=\"language-ts is-loaded\"><span class=\"token keyword\">type</span> <span class=\"token class-name\">StatusCode</span> <span class=\"token operator\">=</span> <span class=\"token number\">200</span> <span class=\"token operator\">|</span> <span class=\"token number\">301</span> <span class=\"token operator\">|</span> <span class=\"token number\">400</span> <span class=\"token operator\">|</span> <span class=\"token number\">500</span> <span class=\"token operator\">|</span> <span class=\"token number\">502</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">type</span> <span class=\"token class-name\">PossibleDataTypes</span> <span class=\"token operator\">=</span> <span class=\"token builtin\">string</span> <span class=\"token operator\">|</span> <span class=\"token builtin\">number</span> <span class=\"token operator\">|</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=&gt;</span> <span class=\"token builtin\">unknown</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">const</span> status<span class=\"token operator\">:</span> StatusCode <span class=\"token operator\">=</span> <span class=\"token number\">502</span><span class=\"token punctuation\">;</span>\n</code><button class=\"copy-code-button\">复制</button></pre>\n<pre class=\"language-ts\" tabindex=\"0\"><code class=\"language-ts is-loaded\"><span class=\"token keyword\">type</span> <span class=\"token class-name\">Handler</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>e<span class=\"token operator\">:</span> Event<span class=\"token punctuation\">)</span> <span class=\"token operator\">=&gt;</span> <span class=\"token keyword\">void</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">const</span> clickHandler<span class=\"token operator\">:</span> <span class=\"token function-variable function\">Handler</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>e<span class=\"token punctuation\">)</span> <span class=\"token operator\">=&gt;</span> <span class=\"token punctuation\">{</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> moveHandler<span class=\"token operator\">:</span> <span class=\"token function-variable function\">Handler</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>e<span class=\"token punctuation\">)</span> <span class=\"token operator\">=&gt;</span> <span class=\"token punctuation\">{</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> dragHandler<span class=\"token operator\">:</span> <span class=\"token function-variable function\">Handler</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>e<span class=\"token punctuation\">)</span> <span class=\"token operator\">=&gt;</span> <span class=\"token punctuation\">{</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n</code><button class=\"copy-code-button\">复制</button></pre>\n<p>在类型别名中，类型别名可以这么声明自己能够接受泛型。一旦接受了泛型，我们就叫它工具类型：</p>\n<pre class=\"language-ts\" tabindex=\"0\"><code class=\"language-ts is-loaded\"><span class=\"token keyword\">type</span> <span class=\"token class-name\">Factory<span class=\"token operator\">&lt;</span><span class=\"token constant\">T</span><span class=\"token operator\">&gt;</span></span> <span class=\"token operator\">=</span> <span class=\"token constant\">T</span> <span class=\"token operator\">|</span> <span class=\"token builtin\">number</span> <span class=\"token operator\">|</span> <span class=\"token builtin\">string</span><span class=\"token punctuation\">;</span>\n</code><button class=\"copy-code-button\">复制</button></pre>\n<p>我们一般不会直接使用工具类型来做类型标注，而是再度声明一个新的类型别名</p>\n<pre class=\"language-ts\" tabindex=\"0\"><code class=\"language-ts is-loaded\"><span class=\"token keyword\">type</span> <span class=\"token class-name\">FactoryWithBool</span> <span class=\"token operator\">=</span> Factory<span class=\"token operator\">&lt;</span><span class=\"token builtin\">boolean</span><span class=\"token operator\">&gt;</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">const</span> foo<span class=\"token operator\">:</span> FactoryWithBool <span class=\"token operator\">=</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n</code><button class=\"copy-code-button\">复制</button></pre>\n<pre class=\"language-ts\" tabindex=\"0\"><code class=\"language-ts is-loaded\"><span class=\"token keyword\">type</span> <span class=\"token class-name\">MaybeNull<span class=\"token operator\">&lt;</span><span class=\"token constant\">T</span><span class=\"token operator\">&gt;</span></span> <span class=\"token operator\">=</span> <span class=\"token constant\">T</span> <span class=\"token operator\">|</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">type</span> <span class=\"token class-name\">MaybeArray<span class=\"token operator\">&lt;</span><span class=\"token constant\">T</span><span class=\"token operator\">&gt;</span></span> <span class=\"token operator\">=</span> <span class=\"token constant\">T</span> <span class=\"token operator\">|</span> <span class=\"token constant\">T</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n</code><button class=\"copy-code-button\">复制</button></pre>\n<p>类型别名中可以接受任意个泛型，以及为泛型指定约束、默认值。</p>\n<p>交叉类型，使用 <code>&amp;</code>，需要符合这里的所有类型，才可以说实现了这个交叉类型，即 A &amp; B，需要同时满足 A 与 B 两个类型才行。</p>\n<pre class=\"language-ts\" tabindex=\"0\"><code class=\"language-ts is-loaded\"><span class=\"token keyword\">interface</span> <span class=\"token class-name\">NameStruct</span> <span class=\"token punctuation\">{</span>\n  name<span class=\"token operator\">:</span> <span class=\"token builtin\">string</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">interface</span> <span class=\"token class-name\">AgeStruct</span> <span class=\"token punctuation\">{</span>\n  age<span class=\"token operator\">:</span> <span class=\"token builtin\">number</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">type</span> <span class=\"token class-name\">ProfileStruct</span> <span class=\"token operator\">=</span> NameStruct <span class=\"token operator\">&amp;</span> AgeStruct<span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">const</span> profile<span class=\"token operator\">:</span> ProfileStruct <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n  name<span class=\"token operator\">:</span> <span class=\"token string\">\"linbudu\"</span><span class=\"token punctuation\">,</span>\n  age<span class=\"token operator\">:</span> <span class=\"token number\">18</span>\n<span class=\"token punctuation\">}</span>\n</code><button class=\"copy-code-button\">复制</button></pre>\n<pre class=\"language-ts\" tabindex=\"0\"><code class=\"language-ts is-loaded\"><span class=\"token keyword\">type</span> <span class=\"token class-name\">StrAndNum</span> <span class=\"token operator\">=</span> <span class=\"token builtin\">string</span> <span class=\"token operator\">&amp;</span> <span class=\"token builtin\">number</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// never</span>\n</code><button class=\"copy-code-button\">复制</button></pre>\n<p>存在既是 string 又是 number 的类型吗？当然不。</p>\n<p>对于对象类型的交叉类型，其内部的同名属性类型同样会按照交叉类型进行合并</p>\n<pre class=\"language-ts\" tabindex=\"0\"><code class=\"language-ts is-loaded\"><span class=\"token keyword\">type</span> <span class=\"token class-name\">Struct1</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n  primitiveProp<span class=\"token operator\">:</span> <span class=\"token builtin\">string</span><span class=\"token punctuation\">;</span>\n  objectProp<span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n    name<span class=\"token operator\">:</span> <span class=\"token builtin\">string</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">type</span> <span class=\"token class-name\">Struct2</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n  primitiveProp<span class=\"token operator\">:</span> <span class=\"token builtin\">number</span><span class=\"token punctuation\">;</span>\n  objectProp<span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n    age<span class=\"token operator\">:</span> <span class=\"token builtin\">number</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">type</span> <span class=\"token class-name\">Composed</span> <span class=\"token operator\">=</span> Struct1 <span class=\"token operator\">&amp;</span> Struct2<span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">type</span> <span class=\"token class-name\">PrimitivePropType</span> <span class=\"token operator\">=</span> Composed<span class=\"token punctuation\">[</span><span class=\"token string\">'primitiveProp'</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// never</span>\n<span class=\"token keyword\">type</span> <span class=\"token class-name\">ObjectPropType</span> <span class=\"token operator\">=</span> Composed<span class=\"token punctuation\">[</span><span class=\"token string\">'objectProp'</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// { name: string; age: number; }</span>\n</code><button class=\"copy-code-button\">复制</button></pre>\n<pre class=\"language-ts\" tabindex=\"0\"><code class=\"language-ts is-loaded\"><span class=\"token keyword\">type</span> <span class=\"token class-name\">UnionIntersection1</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token number\">1</span> <span class=\"token operator\">|</span> <span class=\"token number\">2</span> <span class=\"token operator\">|</span> <span class=\"token number\">3</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">&amp;</span> <span class=\"token punctuation\">(</span><span class=\"token number\">1</span> <span class=\"token operator\">|</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 1 | 2</span>\n<span class=\"token keyword\">type</span> <span class=\"token class-name\">UnionIntersection2</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token builtin\">string</span> <span class=\"token operator\">|</span> <span class=\"token builtin\">number</span> <span class=\"token operator\">|</span> <span class=\"token builtin\">symbol</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">&amp;</span> <span class=\"token builtin\">string</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// string</span>\n</code><button class=\"copy-code-button\">复制</button></pre>\n<p>索引类型指的不是某一个特定的类型工具，它包含三个部分：索引签名类型、索引类型查询与索引类型访问。</p>\n<p>索引签名类型主要指的是在接口或类型别名中，通过以下语法来快速声明一个键值类型一致的类型结构：</p>\n<pre class=\"language-ts\" tabindex=\"0\"><code class=\"language-ts is-loaded\"><span class=\"token keyword\">interface</span> <span class=\"token class-name\">AllStringTypes</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token punctuation\">[</span>key<span class=\"token operator\">:</span> <span class=\"token builtin\">string</span><span class=\"token punctuation\">]</span><span class=\"token operator\">:</span> <span class=\"token builtin\">string</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">type</span> <span class=\"token class-name\">AllStringTypes</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token punctuation\">[</span>key<span class=\"token operator\">:</span> <span class=\"token builtin\">string</span><span class=\"token punctuation\">]</span><span class=\"token operator\">:</span> <span class=\"token builtin\">string</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code><button class=\"copy-code-button\">复制</button></pre>\n<p>即使你还没声明具体的属性，对于这些类型结构的属性访问也将全部被视为 string 类型</p>\n<pre class=\"language-ts\" tabindex=\"0\"><code class=\"language-ts is-loaded\"><span class=\"token keyword\">interface</span> <span class=\"token class-name\">AllStringTypes</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token punctuation\">[</span>key<span class=\"token operator\">:</span> <span class=\"token builtin\">string</span><span class=\"token punctuation\">]</span><span class=\"token operator\">:</span> <span class=\"token builtin\">string</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">type</span> <span class=\"token class-name\">PropType1</span> <span class=\"token operator\">=</span> AllStringTypes<span class=\"token punctuation\">[</span><span class=\"token string\">'linbudu'</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// string</span>\n<span class=\"token keyword\">type</span> <span class=\"token class-name\">PropType2</span> <span class=\"token operator\">=</span> AllStringTypes<span class=\"token punctuation\">[</span><span class=\"token string\">'599'</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// string</span>\n</code><button class=\"copy-code-button\">复制</button></pre>\n<p>由于 JavaScript 中，对于 obj[prop] 形式的访问会将数字索引访问转换为字符串索引访问，也就是说， obj[599] 和 obj['599'] 的效果是一致的。因此，在字符串索引签名类型中我们仍然可以声明数字类型的键。类似的，symbol 类型也是如此</p>\n<pre class=\"language-ts\" tabindex=\"0\"><code class=\"language-ts is-loaded\"><span class=\"token keyword\">const</span> foo<span class=\"token operator\">:</span> AllStringTypes <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token string-property property\">\"linbudu\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"599\"</span><span class=\"token punctuation\">,</span>\n  <span class=\"token number\">599</span><span class=\"token operator\">:</span> <span class=\"token string\">\"linbudu\"</span><span class=\"token punctuation\">,</span>\n  <span class=\"token punctuation\">[</span><span class=\"token function\">Symbol</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"ddd\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">]</span><span class=\"token operator\">:</span> <span class=\"token string\">'symbol'</span><span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">}</span>\n</code><button class=\"copy-code-button\">复制</button></pre>\n<p>索引签名类型也可以和具体的键值对类型声明并存，但这时这些具体的键值类型也需要符合索引签名类型的声明：</p>\n<pre class=\"language-ts\" tabindex=\"0\"><code class=\"language-ts is-loaded\"><span class=\"token keyword\">interface</span> <span class=\"token class-name\">StringOrBooleanTypes</span> <span class=\"token punctuation\">{</span>\n  propA<span class=\"token operator\">:</span> <span class=\"token builtin\">number</span><span class=\"token punctuation\">;</span>\n  propB<span class=\"token operator\">:</span> <span class=\"token builtin\">boolean</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">[</span>key<span class=\"token operator\">:</span> <span class=\"token builtin\">string</span><span class=\"token punctuation\">]</span><span class=\"token operator\">:</span> <span class=\"token builtin\">number</span> <span class=\"token operator\">|</span> <span class=\"token builtin\">boolean</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code><button class=\"copy-code-button\">复制</button></pre>\n<p>keyof 操作符,可以将对象中的所有键转换为对应字面量类型，然后再组合成联合类型。</p>\n<pre class=\"language-ts\" tabindex=\"0\"><code class=\"language-ts is-loaded\"><span class=\"token keyword\">interface</span> <span class=\"token class-name\">Foo</span> <span class=\"token punctuation\">{</span>\n  linbudu<span class=\"token operator\">:</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span>\n  <span class=\"token number\">599</span><span class=\"token operator\">:</span> <span class=\"token number\">2</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">type</span> <span class=\"token class-name\">FooKeys</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">keyof</span> Foo<span class=\"token punctuation\">;</span> <span class=\"token comment\">// \"linbudu\" | 599</span>\n</code><button class=\"copy-code-button\">复制</button></pre>\n<p>除了应用在已知的对象类型结构上以外，你还可以直接 keyof any 来生产一个联合类型，它会由所有可用作对象键值的类型组成：string | number | symbol。也就是说，它是由无数字面量类型组成的，由此我们可以知道， keyof 的产物必定是一个联合类型。</p>\n<p>类型查询</p>\n<pre class=\"language-ts\" tabindex=\"0\"><code class=\"language-ts is-loaded\"><span class=\"token keyword\">interface</span> <span class=\"token class-name\">NumberRecord</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token punctuation\">[</span>key<span class=\"token operator\">:</span> <span class=\"token builtin\">string</span><span class=\"token punctuation\">]</span><span class=\"token operator\">:</span> <span class=\"token builtin\">number</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">type</span> <span class=\"token class-name\">PropType</span> <span class=\"token operator\">=</span> NumberRecord<span class=\"token punctuation\">[</span><span class=\"token builtin\">string</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// number</span>\n</code><button class=\"copy-code-button\">复制</button></pre>\n<pre class=\"language-ts\" tabindex=\"0\"><code class=\"language-ts is-loaded\"><span class=\"token keyword\">interface</span> <span class=\"token class-name\">Foo</span> <span class=\"token punctuation\">{</span>\n  propA<span class=\"token operator\">:</span> <span class=\"token builtin\">number</span><span class=\"token punctuation\">;</span>\n  propB<span class=\"token operator\">:</span> <span class=\"token builtin\">boolean</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">type</span> <span class=\"token class-name\">PropAType</span> <span class=\"token operator\">=</span> Foo<span class=\"token punctuation\">[</span><span class=\"token string\">'propA'</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// number</span>\n<span class=\"token keyword\">type</span> <span class=\"token class-name\">PropBType</span> <span class=\"token operator\">=</span> Foo<span class=\"token punctuation\">[</span><span class=\"token string\">'propB'</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// boolean</span>\n</code><button class=\"copy-code-button\">复制</button></pre>\n<pre class=\"language-ts\" tabindex=\"0\"><code class=\"language-ts is-loaded\"><span class=\"token keyword\">interface</span> <span class=\"token class-name\">Foo</span> <span class=\"token punctuation\">{</span>\n  propA<span class=\"token operator\">:</span> <span class=\"token builtin\">number</span><span class=\"token punctuation\">;</span>\n  propB<span class=\"token operator\">:</span> <span class=\"token builtin\">boolean</span><span class=\"token punctuation\">;</span>\n  propC<span class=\"token operator\">:</span> <span class=\"token builtin\">string</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">type</span> <span class=\"token class-name\">PropTypeUnion</span> <span class=\"token operator\">=</span> Foo<span class=\"token punctuation\">[</span><span class=\"token keyword\">keyof</span> Foo<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// string | number | boolean</span>\n</code><button class=\"copy-code-button\">复制</button></pre>\n<p>在未声明索引签名类型的情况下，我们不能使用 NumberRecord[string] 这种原始类型的访问方式，而只能通过键名的字面量类型来进行访问。</p>\n<pre class=\"language-ts\" tabindex=\"0\"><code class=\"language-ts is-loaded\"><span class=\"token keyword\">interface</span> <span class=\"token class-name\">Foo</span> <span class=\"token punctuation\">{</span>\n  propA<span class=\"token operator\">:</span> <span class=\"token builtin\">number</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\">// 类型“Foo”没有匹配的类型“string”的索引签名。</span>\n<span class=\"token keyword\">type</span> <span class=\"token class-name\">PropAType</span> <span class=\"token operator\">=</span> Foo<span class=\"token punctuation\">[</span><span class=\"token builtin\">string</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span> \n</code><button class=\"copy-code-button\">复制</button></pre>\n<p>映射类型指的就是一个确切的类型工具</p>\n<pre class=\"language-ts\" tabindex=\"0\"><code class=\"language-ts is-loaded\"><span class=\"token keyword\">type</span> <span class=\"token class-name\">Stringify<span class=\"token operator\">&lt;</span><span class=\"token constant\">T</span><span class=\"token operator\">&gt;</span></span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token punctuation\">[</span><span class=\"token constant\">K</span> <span class=\"token keyword\">in</span> <span class=\"token keyword\">keyof</span> <span class=\"token constant\">T</span><span class=\"token punctuation\">]</span><span class=\"token operator\">:</span> <span class=\"token builtin\">string</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n</code><button class=\"copy-code-button\">复制</button></pre>\n<pre class=\"language-ts\" tabindex=\"0\"><code class=\"language-ts is-loaded\"><span class=\"token keyword\">type</span> <span class=\"token class-name\">Clone<span class=\"token operator\">&lt;</span><span class=\"token constant\">T</span><span class=\"token operator\">&gt;</span></span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token punctuation\">[</span><span class=\"token constant\">K</span> <span class=\"token keyword\">in</span> <span class=\"token keyword\">keyof</span> <span class=\"token constant\">T</span><span class=\"token punctuation\">]</span><span class=\"token operator\">:</span> <span class=\"token constant\">T</span><span class=\"token punctuation\">[</span><span class=\"token constant\">K</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n</code><button class=\"copy-code-button\">复制</button></pre>",
      "tags": [
        "类型工具"
      ],
      "createTime": 1665840836509,
      "updateTime": 1665844775913,
      "uuid": "4ccd47b0-2328-4f2b-a7c9-ae95a238e3fe",
      "isCreated": true
    },
    {
      "content": "- 最顶级的类型，any 与 unknown\n- 特殊的 Object ，它也包含了所有的类型，但和 Top Type 比还是差了一层\n- String、Boolean、Number 这些装箱类型\n- 原始类型与对象类型\n- 字面量类型，即更精确的原始类型与对象类型嘛，需要注意的是 null 和 undefined 并不是字面量类型的子类型\n- 最底层的 never",
      "preview": "<ul>\n<li>最顶级的类型，any 与 unknown</li>\n<li>特殊的 Object ，它也包含了所有的类型，但和 Top Type 比还是差了一层</li>\n<li>String、Boolean、Number 这些装箱类型</li>\n<li>原始类型与对象类型</li>\n<li>字面量类型，即更精确的原始类型与对象类型嘛，需要注意的是 null 和 undefined 并不是字面量类型的子类型</li>\n<li>最底层的 never</li>\n</ul>",
      "tags": [
        "类型层级"
      ],
      "createTime": 1665760669437,
      "updateTime": 1665825052092,
      "uuid": "336cd1d7-9230-4d9a-88ec-cced29093764",
      "isCreated": true
    },
    {
      "content": "还可以 as 到 any 来为所欲为，跳过所有的类型检查：\n\n```ts\nconst str: string = \"linbudu\";\n\n(str as any).func().foo().prop;\n```\n\n类型断言的正确使用方式是，在 TypeScript 类型分析不正确或不符合预期时，将其断言为此处的正确类型。\n\n除了使用 as 语法以外，你也可以使用 <> 语法。它虽然书写更简洁，但效果一致，只是在 TSX 中尖括号断言并不能很好地被分析出来。\n\n类型断言应当是在迫不得己的情况下使用的。在实际场景中，还是 as any 这一种操作更多。但这也是让你的代码编程 AnyScript 的罪魁祸首之一，请务必小心使用。\n\n在使用类型断言时，原类型与断言类型之间差异过大，也就是指鹿为马太过离谱，离谱到了指鹿为霸王龙的程度，TypeScript 会给你一个类型报错\n\n```ts\nconst str: string = \"linbudu\";\n\n// 从 X 类型 到 Y 类型的断言可能是错误的，blabla\n(str as { handler: () => {} }).handler()\n```\n\n它会提醒你先断言到 unknown 类型，再断言到预期类型\n\n```ts\nconst str: string = \"linbudu\";\n\n(str as unknown as { handler: () => {} }).handler();\n\n// 使用尖括号断言\n(<{ handler: () => {} }>(<unknown>str)).handler();\n```\n\n非空断言使用 `!` 语法，即 `obj!.func()!.prop` 的形式标记前面的一个声明一定是非空的（实际上就是剔除了 null 和 undefined 类型）。\n\n\n\n",
      "preview": "<p>还可以 as 到 any 来为所欲为，跳过所有的类型检查：</p>\n<pre class=\"language-ts\" tabindex=\"0\"><code class=\"language-ts is-loaded\"><span class=\"token keyword\">const</span> str<span class=\"token operator\">:</span> <span class=\"token builtin\">string</span> <span class=\"token operator\">=</span> <span class=\"token string\">\"linbudu\"</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token punctuation\">(</span>str <span class=\"token keyword\">as</span> <span class=\"token builtin\">any</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">func</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">foo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>prop<span class=\"token punctuation\">;</span>\n</code><button class=\"copy-code-button\">复制</button></pre>\n<p>类型断言的正确使用方式是，在 TypeScript 类型分析不正确或不符合预期时，将其断言为此处的正确类型。</p>\n<p>除了使用 as 语法以外，你也可以使用 &lt;&gt; 语法。它虽然书写更简洁，但效果一致，只是在 TSX 中尖括号断言并不能很好地被分析出来。</p>\n<p>类型断言应当是在迫不得己的情况下使用的。在实际场景中，还是 as any 这一种操作更多。但这也是让你的代码编程 AnyScript 的罪魁祸首之一，请务必小心使用。</p>\n<p>在使用类型断言时，原类型与断言类型之间差异过大，也就是指鹿为马太过离谱，离谱到了指鹿为霸王龙的程度，TypeScript 会给你一个类型报错</p>\n<pre class=\"language-ts\" tabindex=\"0\"><code class=\"language-ts is-loaded\"><span class=\"token keyword\">const</span> str<span class=\"token operator\">:</span> <span class=\"token builtin\">string</span> <span class=\"token operator\">=</span> <span class=\"token string\">\"linbudu\"</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// 从 X 类型 到 Y 类型的断言可能是错误的，blabla</span>\n<span class=\"token punctuation\">(</span>str <span class=\"token keyword\">as</span> <span class=\"token punctuation\">{</span> <span class=\"token function-variable function\">handler</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=&gt;</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">handler</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n</code><button class=\"copy-code-button\">复制</button></pre>\n<p>它会提醒你先断言到 unknown 类型，再断言到预期类型</p>\n<pre class=\"language-ts\" tabindex=\"0\"><code class=\"language-ts is-loaded\"><span class=\"token keyword\">const</span> str<span class=\"token operator\">:</span> <span class=\"token builtin\">string</span> <span class=\"token operator\">=</span> <span class=\"token string\">\"linbudu\"</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token punctuation\">(</span>str <span class=\"token keyword\">as</span> <span class=\"token builtin\">unknown</span> <span class=\"token keyword\">as</span> <span class=\"token punctuation\">{</span> <span class=\"token function-variable function\">handler</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=&gt;</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">handler</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// 使用尖括号断言</span>\n<span class=\"token punctuation\">(</span><span class=\"token operator\">&lt;</span><span class=\"token punctuation\">{</span> <span class=\"token function-variable function\">handler</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=&gt;</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span> <span class=\"token punctuation\">}</span><span class=\"token operator\">&gt;</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&lt;</span><span class=\"token builtin\">unknown</span><span class=\"token operator\">&gt;</span>str<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">handler</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code><button class=\"copy-code-button\">复制</button></pre>\n<p>非空断言使用 <code>!</code> 语法，即 <code>obj!.func()!.prop</code> 的形式标记前面的一个声明一定是非空的（实际上就是剔除了 null 和 undefined 类型）。</p>",
      "tags": [],
      "createTime": 1665760435100,
      "updateTime": 1665760435100,
      "uuid": "bd466e37-27bb-414f-9f2d-10232ea4aaf9",
      "isCreated": true,
      "isDeleted": true
    },
    {
      "content": "类型断言能够显式告知类型检查程序当前这个变量的类型，可以进行类型分析地修正、类型。它其实就是一个将变量的已有类型更改为新指定类型的操作。\n\n还可以 as 到 any 来为所欲为，跳过所有的类型检查：\n\n```ts\nconst str: string = \"linbudu\";\n\n(str as any).func().foo().prop;\n```\n\n类型断言的正确使用方式是，在 TypeScript 类型分析不正确或不符合预期时，将其断言为此处的正确类型。\n\n除了使用 as 语法以外，你也可以使用 <> 语法。它虽然书写更简洁，但效果一致，只是在 TSX 中尖括号断言并不能很好地被分析出来。\n\n类型断言应当是在迫不得己的情况下使用的。在实际场景中，还是 as any 这一种操作更多。但这也是让你的代码编程 AnyScript 的罪魁祸首之一，请务必小心使用。\n\n在使用类型断言时，原类型与断言类型之间差异过大，也就是指鹿为马太过离谱，离谱到了指鹿为霸王龙的程度，TypeScript 会给你一个类型报错\n\n```ts\nconst str: string = \"linbudu\";\n\n// 从 X 类型 到 Y 类型的断言可能是错误的，blabla\n(str as { handler: () => {} }).handler()\n```\n\n它会提醒你先断言到 unknown 类型，再断言到预期类型\n\n```ts\nconst str: string = \"linbudu\";\n\n(str as unknown as { handler: () => {} }).handler();\n\n// 使用尖括号断言\n(<{ handler: () => {} }>(<unknown>str)).handler();\n```\n\n非空断言使用 `!` 语法，即 `obj!.func()!.prop` 的形式标记前面的一个声明一定是非空的（实际上就是剔除了 null 和 undefined 类型）。\n\n\n\n",
      "preview": "<p>类型断言能够显式告知类型检查程序当前这个变量的类型，可以进行类型分析地修正、类型。它其实就是一个将变量的已有类型更改为新指定类型的操作。</p>\n<p>还可以 as 到 any 来为所欲为，跳过所有的类型检查：</p>\n<pre class=\"language-ts\" tabindex=\"0\"><code class=\"language-ts is-loaded\"><span class=\"token keyword\">const</span> str<span class=\"token operator\">:</span> <span class=\"token builtin\">string</span> <span class=\"token operator\">=</span> <span class=\"token string\">\"linbudu\"</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token punctuation\">(</span>str <span class=\"token keyword\">as</span> <span class=\"token builtin\">any</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">func</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">foo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>prop<span class=\"token punctuation\">;</span>\n</code><button class=\"copy-code-button\">复制</button></pre>\n<p>类型断言的正确使用方式是，在 TypeScript 类型分析不正确或不符合预期时，将其断言为此处的正确类型。</p>\n<p>除了使用 as 语法以外，你也可以使用 &lt;&gt; 语法。它虽然书写更简洁，但效果一致，只是在 TSX 中尖括号断言并不能很好地被分析出来。</p>\n<p>类型断言应当是在迫不得己的情况下使用的。在实际场景中，还是 as any 这一种操作更多。但这也是让你的代码编程 AnyScript 的罪魁祸首之一，请务必小心使用。</p>\n<p>在使用类型断言时，原类型与断言类型之间差异过大，也就是指鹿为马太过离谱，离谱到了指鹿为霸王龙的程度，TypeScript 会给你一个类型报错</p>\n<pre class=\"language-ts\" tabindex=\"0\"><code class=\"language-ts is-loaded\"><span class=\"token keyword\">const</span> str<span class=\"token operator\">:</span> <span class=\"token builtin\">string</span> <span class=\"token operator\">=</span> <span class=\"token string\">\"linbudu\"</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// 从 X 类型 到 Y 类型的断言可能是错误的，blabla</span>\n<span class=\"token punctuation\">(</span>str <span class=\"token keyword\">as</span> <span class=\"token punctuation\">{</span> <span class=\"token function-variable function\">handler</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=&gt;</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">handler</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n</code><button class=\"copy-code-button\">复制</button></pre>\n<p>它会提醒你先断言到 unknown 类型，再断言到预期类型</p>\n<pre class=\"language-ts\" tabindex=\"0\"><code class=\"language-ts is-loaded\"><span class=\"token keyword\">const</span> str<span class=\"token operator\">:</span> <span class=\"token builtin\">string</span> <span class=\"token operator\">=</span> <span class=\"token string\">\"linbudu\"</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token punctuation\">(</span>str <span class=\"token keyword\">as</span> <span class=\"token builtin\">unknown</span> <span class=\"token keyword\">as</span> <span class=\"token punctuation\">{</span> <span class=\"token function-variable function\">handler</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=&gt;</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">handler</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// 使用尖括号断言</span>\n<span class=\"token punctuation\">(</span><span class=\"token operator\">&lt;</span><span class=\"token punctuation\">{</span> <span class=\"token function-variable function\">handler</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=&gt;</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span> <span class=\"token punctuation\">}</span><span class=\"token operator\">&gt;</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&lt;</span><span class=\"token builtin\">unknown</span><span class=\"token operator\">&gt;</span>str<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">handler</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code><button class=\"copy-code-button\">复制</button></pre>\n<p>非空断言使用 <code>!</code> 语法，即 <code>obj!.func()!.prop</code> 的形式标记前面的一个声明一定是非空的（实际上就是剔除了 null 和 undefined 类型）。</p>",
      "tags": [
        "类型断言"
      ],
      "createTime": 1665758177931,
      "updateTime": 1665760471897,
      "uuid": "4f0e4993-91d1-4236-87ed-9094531a6b53",
      "isCreated": true
    },
    {
      "content": "TypeScript 中提供了一个内置类型 any ，来表示所谓的任意类型。\n\n使用 let 声明一个变量但不提供初始值，以及不为函数参数提供类型标注，会被隐式推导为 any。\n\n```ts\n// any\nlet foo;\n\n// foo、bar 均为 any\nfunction func(foo, bar){}\n```\n\nany 类型的变量几乎无所不能，它可以在**声明后再次接受任意类型的值，同时可以被赋值给任意其它类型的变量**。\n\n使用 any 类型跳过类型检查。\n\n- 如果是类型不兼容报错导致你使用 any，考虑用类型断言替代\n- 如果是类型太复杂导致你不想全部声明而使用 any，考虑将这一处的类型去断言为你需要的最简类型\n- 如果你是想表达一个未知类型，更合理的方式是使用 unknown。\n\n一个 unknown 类型的变量可以再次赋值为任意其它类型，但只能赋值给 any 与 unknown 类型的变量\n\n```ts\nlet unknownVar: unknown = \"linbudu\";\n\nunknownVar = false;\nunknownVar = \"linbudu\";\nunknownVar = {\n  site: \"juejin\"\n};\n\nunknownVar = () => { }\n\nconst val1: string = unknownVar; // Error\nconst val2: number = unknownVar; // Error\nconst val3: () => {} = unknownVar; // Error\nconst val4: {} = unknownVar; // Error\n\nconst val5: any = unknownVar;\nconst val6: unknown = unknownVar;\n```\n\n通常我们不会显式地声明一个 never 类型，它主要被类型检查所使用。但在某些情况下使用 never 确实是符合逻辑的，比如一个只负责抛出错误的函数：\n\n```ts\nfunction justThrow(): never {\n  throw new Error()\n}\n```\n\n一旦一个返回值类型为 never 的函数被调用，那么下方的代码都会被视为无效的代码（即无法执行到）：\n\n```ts\nfunction justThrow(): never {\n  throw new Error()\n}\n\nfunction foo (input:number){\n  if(input > 1){\n    justThrow();\n    // 等同于 return 语句后的代码，即 Dead Code\n    const name = \"linbudu\";\n  }\n}\n```\n\n假设，我们需要对一个联合类型的每个类型分支进行不同处理：\n\n```ts\ndeclare const strOrNumOrBool: string | number | boolean;\n\nif (typeof strOrNumOrBool === \"string\") {\n  console.log(\"str!\");\n} else if (typeof strOrNumOrBool === \"number\") {\n  console.log(\"num!\");\n} else if (typeof strOrNumOrBool === \"boolean\") {\n  console.log(\"bool!\");\n} else {\n  throw new Error(`Unknown input type: ${strOrNumOrBool}`);\n}\n```\n\n如果我们希望这个变量的每一种类型都需要得到妥善处理，在最后可以抛出一个错误，但这是运行时才会生效的措施，是否能在类型检查时就分析出来？\n\n由于 TypeScript 强大的类型分析能力，每经过一个 if 语句处理，strOrNumOrBool 的类型分支就会减少一个（因为已经被对应的 typeof 处理过）。而在最后的 else 代码块中，它的类型只剩下了 never 类型，即一个无法再细分、本质上并不存在的虚空类型。在这里，我们可以利用只有 never 类型能赋值给 never 类型这一点，来巧妙地分支处理检查\n\n假设某个粗心的同事新增了一个类型分支，strOrNumOrBool 变成了 strOrNumOrBoolOrFunc，却忘记新增对应的处理分支，此时在 else 代码块中就会出现将 Function 类型赋值给 never 类型变量的类型错误。这实际上就是利用了类型分析能力与 never 类型只能赋值给 never 类型这一点，来确保联合类型变量被妥善处理。\n\nnever 其实还会在某些情况下不请自来\n\n```ts\nconst arr = [];\n\narr.push(\"linbudu\"); // 类型“string”的参数不能赋给类型“never”的参数。\n```\n\n这个未标明类型的数组被推导为了 never[] 类型，这种情况仅会在你启用了 strictNullChecks 配置，同时禁用了 noImplicitAny 配置时才会出现。解决的办法也很简单，为这个数组声明一个具体类型即可。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",
      "preview": "<p>TypeScript 中提供了一个内置类型 any ，来表示所谓的任意类型。</p>\n<p>使用 let 声明一个变量但不提供初始值，以及不为函数参数提供类型标注，会被隐式推导为 any。</p>\n<pre class=\"language-ts\" tabindex=\"0\"><code class=\"language-ts is-loaded\"><span class=\"token comment\">// any</span>\n<span class=\"token keyword\">let</span> foo<span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// foo、bar 均为 any</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">func</span><span class=\"token punctuation\">(</span>foo<span class=\"token punctuation\">,</span> bar<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n</code><button class=\"copy-code-button\">复制</button></pre>\n<p>any 类型的变量几乎无所不能，它可以在<strong>声明后再次接受任意类型的值，同时可以被赋值给任意其它类型的变量</strong>。</p>\n<p>使用 any 类型跳过类型检查。</p>\n<ul>\n<li>如果是类型不兼容报错导致你使用 any，考虑用类型断言替代</li>\n<li>如果是类型太复杂导致你不想全部声明而使用 any，考虑将这一处的类型去断言为你需要的最简类型</li>\n<li>如果你是想表达一个未知类型，更合理的方式是使用 unknown。</li>\n</ul>\n<p>一个 unknown 类型的变量可以再次赋值为任意其它类型，但只能赋值给 any 与 unknown 类型的变量</p>\n<pre class=\"language-ts\" tabindex=\"0\"><code class=\"language-ts is-loaded\"><span class=\"token keyword\">let</span> unknownVar<span class=\"token operator\">:</span> <span class=\"token builtin\">unknown</span> <span class=\"token operator\">=</span> <span class=\"token string\">\"linbudu\"</span><span class=\"token punctuation\">;</span>\n\nunknownVar <span class=\"token operator\">=</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span>\nunknownVar <span class=\"token operator\">=</span> <span class=\"token string\">\"linbudu\"</span><span class=\"token punctuation\">;</span>\nunknownVar <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n  site<span class=\"token operator\">:</span> <span class=\"token string\">\"juejin\"</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token function-variable function\">unknownVar</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=&gt;</span> <span class=\"token punctuation\">{</span> <span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">const</span> val1<span class=\"token operator\">:</span> <span class=\"token builtin\">string</span> <span class=\"token operator\">=</span> unknownVar<span class=\"token punctuation\">;</span> <span class=\"token comment\">// Error</span>\n<span class=\"token keyword\">const</span> val2<span class=\"token operator\">:</span> <span class=\"token builtin\">number</span> <span class=\"token operator\">=</span> unknownVar<span class=\"token punctuation\">;</span> <span class=\"token comment\">// Error</span>\n<span class=\"token keyword\">const</span> <span class=\"token function-variable function\">val3</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=&gt;</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span> <span class=\"token operator\">=</span> unknownVar<span class=\"token punctuation\">;</span> <span class=\"token comment\">// Error</span>\n<span class=\"token keyword\">const</span> val4<span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span> <span class=\"token operator\">=</span> unknownVar<span class=\"token punctuation\">;</span> <span class=\"token comment\">// Error</span>\n\n<span class=\"token keyword\">const</span> val5<span class=\"token operator\">:</span> <span class=\"token builtin\">any</span> <span class=\"token operator\">=</span> unknownVar<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> val6<span class=\"token operator\">:</span> <span class=\"token builtin\">unknown</span> <span class=\"token operator\">=</span> unknownVar<span class=\"token punctuation\">;</span>\n</code><button class=\"copy-code-button\">复制</button></pre>\n<p>通常我们不会显式地声明一个 never 类型，它主要被类型检查所使用。但在某些情况下使用 never 确实是符合逻辑的，比如一个只负责抛出错误的函数：</p>\n<pre class=\"language-ts\" tabindex=\"0\"><code class=\"language-ts is-loaded\"><span class=\"token keyword\">function</span> <span class=\"token function\">justThrow</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token builtin\">never</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">throw</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Error</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span>\n</code><button class=\"copy-code-button\">复制</button></pre>\n<p>一旦一个返回值类型为 never 的函数被调用，那么下方的代码都会被视为无效的代码（即无法执行到）：</p>\n<pre class=\"language-ts\" tabindex=\"0\"><code class=\"language-ts is-loaded\"><span class=\"token keyword\">function</span> <span class=\"token function\">justThrow</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token builtin\">never</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">throw</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Error</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">function</span> <span class=\"token function\">foo</span> <span class=\"token punctuation\">(</span>input<span class=\"token operator\">:</span><span class=\"token builtin\">number</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>input <span class=\"token operator\">&gt;</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    <span class=\"token function\">justThrow</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\">// 等同于 return 语句后的代码，即 Dead Code</span>\n    <span class=\"token keyword\">const</span> name <span class=\"token operator\">=</span> <span class=\"token string\">\"linbudu\"</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n</code><button class=\"copy-code-button\">复制</button></pre>\n<p>假设，我们需要对一个联合类型的每个类型分支进行不同处理：</p>\n<pre class=\"language-ts\" tabindex=\"0\"><code class=\"language-ts is-loaded\"><span class=\"token keyword\">declare</span> <span class=\"token keyword\">const</span> strOrNumOrBool<span class=\"token operator\">:</span> <span class=\"token builtin\">string</span> <span class=\"token operator\">|</span> <span class=\"token builtin\">number</span> <span class=\"token operator\">|</span> <span class=\"token builtin\">boolean</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">typeof</span> strOrNumOrBool <span class=\"token operator\">===</span> <span class=\"token string\">\"string\"</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token builtin\">console</span><span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"str!\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">typeof</span> strOrNumOrBool <span class=\"token operator\">===</span> <span class=\"token string\">\"number\"</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token builtin\">console</span><span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"num!\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">typeof</span> strOrNumOrBool <span class=\"token operator\">===</span> <span class=\"token string\">\"boolean\"</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token builtin\">console</span><span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"bool!\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">throw</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Error</span><span class=\"token punctuation\">(</span><span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token string\">Unknown input type: </span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span>strOrNumOrBool<span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token template-punctuation string\">`</span></span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code><button class=\"copy-code-button\">复制</button></pre>\n<p>如果我们希望这个变量的每一种类型都需要得到妥善处理，在最后可以抛出一个错误，但这是运行时才会生效的措施，是否能在类型检查时就分析出来？</p>\n<p>由于 TypeScript 强大的类型分析能力，每经过一个 if 语句处理，strOrNumOrBool 的类型分支就会减少一个（因为已经被对应的 typeof 处理过）。而在最后的 else 代码块中，它的类型只剩下了 never 类型，即一个无法再细分、本质上并不存在的虚空类型。在这里，我们可以利用只有 never 类型能赋值给 never 类型这一点，来巧妙地分支处理检查</p>\n<p>假设某个粗心的同事新增了一个类型分支，strOrNumOrBool 变成了 strOrNumOrBoolOrFunc，却忘记新增对应的处理分支，此时在 else 代码块中就会出现将 Function 类型赋值给 never 类型变量的类型错误。这实际上就是利用了类型分析能力与 never 类型只能赋值给 never 类型这一点，来确保联合类型变量被妥善处理。</p>\n<p>never 其实还会在某些情况下不请自来</p>\n<pre class=\"language-ts\" tabindex=\"0\"><code class=\"language-ts is-loaded\"><span class=\"token keyword\">const</span> arr <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\narr<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"linbudu\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 类型“string”的参数不能赋给类型“never”的参数。</span>\n</code><button class=\"copy-code-button\">复制</button></pre>\n<p>这个未标明类型的数组被推导为了 never[] 类型，这种情况仅会在你启用了 strictNullChecks 配置，同时禁用了 noImplicitAny 配置时才会出现。解决的办法也很简单，为这个数组声明一个具体类型即可。</p>",
      "tags": [
        "any、unknown与never"
      ],
      "createTime": 1665757812300,
      "updateTime": 1665757812300,
      "uuid": "b53b5577-3dce-489e-b92c-323b7faea670",
      "isCreated": true
    },
    {
      "content": "函数的类型就是描述了函数入参类型与函数返回值类型。\n\n在函数类型中同样存在着类型推导。\n\n箭头函数类型标注：\n\n```ts\n// 方式一\nconst foo = (name: string): number => {\n  return name.length\n}\n\n// 方式二\nconst foo: (name: string) => number = (name) => {\n  return name.length\n}\n```\n\n方式二的声明方式中，代码的可读性非常差，不推荐这么使用，要么直接在函数中进行参数和返回值的类型声明，要么使用类型别名将函数声明抽离出来。\n\n一个没有返回值（即没有调用 `return` 语句）的函数，其返回类型应当被标记为 `void` 而不是 `undefined`，即使它实际的值是 `undefined`。\n\n在函数类型中我们也使用 ? 描述一个可选参数\n\n```ts\n// 在函数逻辑中注入可选参数默认值\nfunction foo1(name: string, age?: number): number {\n  const inputAge = age ?? 18; // 或使用 age ?? 18\n  return name.length + inputAge\n}\n\n// 直接为可选参数声明默认值\nfunction foo2(name: string, age: number = 18): number {\n  const inputAge = age;\n  return name.length + inputAge\n}\n```\n\n重载：在某些逻辑较复杂的情况下，函数可能有多组入参类型和返回值类型\n\n```ts\nfunction func(foo: number, bar?: boolean): string | number {\n  if (bar) {\n    return String(foo);\n  } else {\n    return foo * 599;\n  }\n}\n```\n\n```ts\nfunction func(foo: number, bar: true): string;\nfunction func(foo: number, bar?: false): number;\nfunction func(foo: number, bar?: boolean): string | number {\n  if (bar) {\n    return String(foo);\n  } else {\n    return foo * 599;\n  }\n}\n\nconst res1 = func(599); // number\nconst res2 = func(599, true); // string\nconst res3 = func(599, false); // number\n```\n\n拥有多个重载声明的函数在被调用时，是按照重载的声明顺序往下查找的。因此在第一个重载声明中，为了与逻辑中保持一致，即在 bar 为 true 时返回 string 类型，这里我们需要将第一个重载声明的 bar 声明为必选的字面量类型（否则因为是可选的，不管传没传都符合，不会继续向下查找了）。\n\n```note\n那上面最后一个函数的重载是不是可以不写，因为查找不到最后一个。\n```\n\n异步函数、Generator 函数、异步 Generator 函数的类型签名，其参数签名基本一致，而返回值类型则稍微有些区别：\n\n```ts\nasync function asyncFunc(): Promise<void> {}\n\nfunction* genFunc(): Iterable<void> {}\n\nasync function* asyncGenFunc(): AsyncIterable<void> {}\n```\n\nGenerator 函数与异步 Generator 函数现在已经基本不再使用，这里仅做了解即可。\n\n属性的类型标注类似于变量，而构造函数、方法、存取器的类型编标注类似于函数：\n\n```ts\nclass Foo {\n  prop: string;\n\n  constructor(inputProp: string) {\n    this.prop = inputProp;\n  }\n\n  print(addon: string): void {\n    console.log(`${this.prop} and ${addon}`)\n  }\n\n  get propA(): string {\n    return `${this.prop}+A`;\n  }\n\n  set propA(value: string) {\n    this.prop = `${value}+A`\n  }\n}\n```\n\nsetter 方法不允许进行返回值的类型标注，你可以理解为 setter 的返回值并不会被消费，它是一个只关注过程的函数。类的方法同样可以进行函数那样的重载，且语法基本一致。\n\nClass 成员的修饰符：public / private / protected / readonly。除 readonly 以外，其他三位都属于访问性修饰符，而 readonly 属于操作性修饰符。\n\n修饰符应用的位置在成员命名前。\n\n> 通常不会为构造函数添加修饰符，而是让它保持默认的 public。\n\n- public：此类成员在类、类的实例、子类中都能被访问。\n- private：此类成员仅能在类的内部被访问。\n- protected：此类成员仅能在类与子类中被访问\n\n成员的访问性默认会被标记为 public，可以在构造函数中对参数应用访问性修饰符：\n\n```ts\nclass Foo {\n  constructor(public arg1: string, private arg2: boolean) { }\n}\n\nnew Foo(\"linbudu\", true)\n```\n\n此时，参数会被直接作为类的成员（即实例的属性），免去后续的手动赋值。\n\n使用 static 关键字来标识一个成员为静态成员，在类的内部静态成员无法通过 this 来访问，需要通过 `类型.静态成员` 这种形式进行访问。\n\n静态成员直接被挂载在函数体上，而实例成员挂载在原型上，这就是二者的最重要差异：静态成员不会被实例继承，它始终只属于当前定义的这个类（以及其子类）。而原型对象上的实例成员则会沿着原型链进行传递，也就是能够被继承。\n\nTypeScript 使用 extends 关键字来实现继承。\n\nTypeScript 4.3 新增了 override 关键字，来确保派生类尝试覆盖的方法一定在基类中存在定义。\n\n抽象类是对类结构与方法的抽象，简单来说，一个抽象类描述了一个类中应当有哪些成员（属性、方法等），一个抽象方法描述了这一方法在实际实现中的结构。抽象类使用 abstract 关键字声明：\n\n```ts\nabstract class AbsFoo {\n  abstract absProp: string;\n  abstract get absGetter(): string;\n  abstract absMethod(name: string): string\n}\n```\n\n在 TypeScript 中无法声明静态的抽象成员。对于抽象类，它的本质就是描述类的结构。interface 不仅可以声明函数结构，也可以声明类的结构:\n\n```ts\ninterface FooStruct {\n  absProp: string;\n  get absGetter(): string;\n  absMethod(input: string): string\n}\n```\n\n```note\ninterface 怎么声明函数的结构。\n```\n\n```note\nJavaScript 中不存在 static 吗？\n```\n\n\n",
      "preview": "<p>函数的类型就是描述了函数入参类型与函数返回值类型。</p>\n<p>在函数类型中同样存在着类型推导。</p>\n<p>箭头函数类型标注：</p>\n<pre class=\"language-ts\" tabindex=\"0\"><code class=\"language-ts is-loaded\"><span class=\"token comment\">// 方式一</span>\n<span class=\"token keyword\">const</span> foo <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>name<span class=\"token operator\">:</span> <span class=\"token builtin\">string</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token builtin\">number</span> <span class=\"token operator\">=&gt;</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> name<span class=\"token punctuation\">.</span>length\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\">// 方式二</span>\n<span class=\"token keyword\">const</span> <span class=\"token function-variable function\">foo</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">(</span>name<span class=\"token operator\">:</span> <span class=\"token builtin\">string</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=&gt;</span> <span class=\"token function-variable function\">number</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>name<span class=\"token punctuation\">)</span> <span class=\"token operator\">=&gt;</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> name<span class=\"token punctuation\">.</span>length\n<span class=\"token punctuation\">}</span>\n</code><button class=\"copy-code-button\">复制</button></pre>\n<p>方式二的声明方式中，代码的可读性非常差，不推荐这么使用，要么直接在函数中进行参数和返回值的类型声明，要么使用类型别名将函数声明抽离出来。</p>\n<p>一个没有返回值（即没有调用 <code>return</code> 语句）的函数，其返回类型应当被标记为 <code>void</code> 而不是 <code>undefined</code>，即使它实际的值是 <code>undefined</code>。</p>\n<p>在函数类型中我们也使用 ? 描述一个可选参数</p>\n<pre class=\"language-ts\" tabindex=\"0\"><code class=\"language-ts is-loaded\"><span class=\"token comment\">// 在函数逻辑中注入可选参数默认值</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">foo1</span><span class=\"token punctuation\">(</span>name<span class=\"token operator\">:</span> <span class=\"token builtin\">string</span><span class=\"token punctuation\">,</span> age<span class=\"token operator\">?</span><span class=\"token operator\">:</span> <span class=\"token builtin\">number</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token builtin\">number</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> inputAge <span class=\"token operator\">=</span> age <span class=\"token operator\">??</span> <span class=\"token number\">18</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 或使用 age ?? 18</span>\n  <span class=\"token keyword\">return</span> name<span class=\"token punctuation\">.</span>length <span class=\"token operator\">+</span> inputAge\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\">// 直接为可选参数声明默认值</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">foo2</span><span class=\"token punctuation\">(</span>name<span class=\"token operator\">:</span> <span class=\"token builtin\">string</span><span class=\"token punctuation\">,</span> age<span class=\"token operator\">:</span> <span class=\"token builtin\">number</span> <span class=\"token operator\">=</span> <span class=\"token number\">18</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token builtin\">number</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> inputAge <span class=\"token operator\">=</span> age<span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">return</span> name<span class=\"token punctuation\">.</span>length <span class=\"token operator\">+</span> inputAge\n<span class=\"token punctuation\">}</span>\n</code><button class=\"copy-code-button\">复制</button></pre>\n<p>重载：在某些逻辑较复杂的情况下，函数可能有多组入参类型和返回值类型</p>\n<pre class=\"language-ts\" tabindex=\"0\"><code class=\"language-ts is-loaded\"><span class=\"token keyword\">function</span> <span class=\"token function\">func</span><span class=\"token punctuation\">(</span>foo<span class=\"token operator\">:</span> <span class=\"token builtin\">number</span><span class=\"token punctuation\">,</span> bar<span class=\"token operator\">?</span><span class=\"token operator\">:</span> <span class=\"token builtin\">boolean</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token builtin\">string</span> <span class=\"token operator\">|</span> <span class=\"token builtin\">number</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>bar<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token function\">String</span><span class=\"token punctuation\">(</span>foo<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> foo <span class=\"token operator\">*</span> <span class=\"token number\">599</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n</code><button class=\"copy-code-button\">复制</button></pre>\n<pre class=\"language-ts\" tabindex=\"0\"><code class=\"language-ts is-loaded\"><span class=\"token keyword\">function</span> <span class=\"token function\">func</span><span class=\"token punctuation\">(</span>foo<span class=\"token operator\">:</span> <span class=\"token builtin\">number</span><span class=\"token punctuation\">,</span> bar<span class=\"token operator\">:</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token builtin\">string</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">func</span><span class=\"token punctuation\">(</span>foo<span class=\"token operator\">:</span> <span class=\"token builtin\">number</span><span class=\"token punctuation\">,</span> bar<span class=\"token operator\">?</span><span class=\"token operator\">:</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token builtin\">number</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">func</span><span class=\"token punctuation\">(</span>foo<span class=\"token operator\">:</span> <span class=\"token builtin\">number</span><span class=\"token punctuation\">,</span> bar<span class=\"token operator\">?</span><span class=\"token operator\">:</span> <span class=\"token builtin\">boolean</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token builtin\">string</span> <span class=\"token operator\">|</span> <span class=\"token builtin\">number</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>bar<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token function\">String</span><span class=\"token punctuation\">(</span>foo<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> foo <span class=\"token operator\">*</span> <span class=\"token number\">599</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">const</span> res1 <span class=\"token operator\">=</span> <span class=\"token function\">func</span><span class=\"token punctuation\">(</span><span class=\"token number\">599</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// number</span>\n<span class=\"token keyword\">const</span> res2 <span class=\"token operator\">=</span> <span class=\"token function\">func</span><span class=\"token punctuation\">(</span><span class=\"token number\">599</span><span class=\"token punctuation\">,</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// string</span>\n<span class=\"token keyword\">const</span> res3 <span class=\"token operator\">=</span> <span class=\"token function\">func</span><span class=\"token punctuation\">(</span><span class=\"token number\">599</span><span class=\"token punctuation\">,</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// number</span>\n</code><button class=\"copy-code-button\">复制</button></pre>\n<p>拥有多个重载声明的函数在被调用时，是按照重载的声明顺序往下查找的。因此在第一个重载声明中，为了与逻辑中保持一致，即在 bar 为 true 时返回 string 类型，这里我们需要将第一个重载声明的 bar 声明为必选的字面量类型（否则因为是可选的，不管传没传都符合，不会继续向下查找了）。</p>\n<div class=\"block-language-note custom-block note\"><p class=\"custom-block-title\">Note</p><p>那上面最后一个函数的重载是不是可以不写，因为查找不到最后一个。</p></div>\n<p>异步函数、Generator 函数、异步 Generator 函数的类型签名，其参数签名基本一致，而返回值类型则稍微有些区别：</p>\n<pre class=\"language-ts\" tabindex=\"0\"><code class=\"language-ts is-loaded\"><span class=\"token keyword\">async</span> <span class=\"token keyword\">function</span> <span class=\"token function\">asyncFunc</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token builtin\">Promise</span><span class=\"token operator\">&lt;</span><span class=\"token keyword\">void</span><span class=\"token operator\">&gt;</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">function</span><span class=\"token operator\">*</span> <span class=\"token function\">genFunc</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> Iterable<span class=\"token operator\">&lt;</span><span class=\"token keyword\">void</span><span class=\"token operator\">&gt;</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">async</span> <span class=\"token keyword\">function</span><span class=\"token operator\">*</span> <span class=\"token function\">asyncGenFunc</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> AsyncIterable<span class=\"token operator\">&lt;</span><span class=\"token keyword\">void</span><span class=\"token operator\">&gt;</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n</code><button class=\"copy-code-button\">复制</button></pre>\n<p>Generator 函数与异步 Generator 函数现在已经基本不再使用，这里仅做了解即可。</p>\n<p>属性的类型标注类似于变量，而构造函数、方法、存取器的类型编标注类似于函数：</p>\n<pre class=\"language-ts\" tabindex=\"0\"><code class=\"language-ts is-loaded\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Foo</span> <span class=\"token punctuation\">{</span>\n  prop<span class=\"token operator\">:</span> <span class=\"token builtin\">string</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token function\">constructor</span><span class=\"token punctuation\">(</span>inputProp<span class=\"token operator\">:</span> <span class=\"token builtin\">string</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>prop <span class=\"token operator\">=</span> inputProp<span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token function\">print</span><span class=\"token punctuation\">(</span>addon<span class=\"token operator\">:</span> <span class=\"token builtin\">string</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token keyword\">void</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token builtin\">console</span><span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>prop<span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token string\"> and </span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span>addon<span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token template-punctuation string\">`</span></span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token keyword\">get</span> <span class=\"token function\">propA</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token builtin\">string</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>prop<span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token string\">+A</span><span class=\"token template-punctuation string\">`</span></span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token keyword\">set</span> <span class=\"token function\">propA</span><span class=\"token punctuation\">(</span>value<span class=\"token operator\">:</span> <span class=\"token builtin\">string</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>prop <span class=\"token operator\">=</span> <span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span>value<span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token string\">+A</span><span class=\"token template-punctuation string\">`</span></span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n</code><button class=\"copy-code-button\">复制</button></pre>\n<p>setter 方法不允许进行返回值的类型标注，你可以理解为 setter 的返回值并不会被消费，它是一个只关注过程的函数。类的方法同样可以进行函数那样的重载，且语法基本一致。</p>\n<p>Class 成员的修饰符：public / private / protected / readonly。除 readonly 以外，其他三位都属于访问性修饰符，而 readonly 属于操作性修饰符。</p>\n<p>修饰符应用的位置在成员命名前。</p>\n<blockquote>\n<p>通常不会为构造函数添加修饰符，而是让它保持默认的 public。</p>\n</blockquote>\n<ul>\n<li>public：此类成员在类、类的实例、子类中都能被访问。</li>\n<li>private：此类成员仅能在类的内部被访问。</li>\n<li>protected：此类成员仅能在类与子类中被访问</li>\n</ul>\n<p>成员的访问性默认会被标记为 public，可以在构造函数中对参数应用访问性修饰符：</p>\n<pre class=\"language-ts\" tabindex=\"0\"><code class=\"language-ts is-loaded\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Foo</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">constructor</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">public</span> arg1<span class=\"token operator\">:</span> <span class=\"token builtin\">string</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">private</span> arg2<span class=\"token operator\">:</span> <span class=\"token builtin\">boolean</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">new</span> <span class=\"token class-name\">Foo</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"linbudu\"</span><span class=\"token punctuation\">,</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span>\n</code><button class=\"copy-code-button\">复制</button></pre>\n<p>此时，参数会被直接作为类的成员（即实例的属性），免去后续的手动赋值。</p>\n<p>使用 static 关键字来标识一个成员为静态成员，在类的内部静态成员无法通过 this 来访问，需要通过 <code>类型.静态成员</code> 这种形式进行访问。</p>\n<p>静态成员直接被挂载在函数体上，而实例成员挂载在原型上，这就是二者的最重要差异：静态成员不会被实例继承，它始终只属于当前定义的这个类（以及其子类）。而原型对象上的实例成员则会沿着原型链进行传递，也就是能够被继承。</p>\n<p>TypeScript 使用 extends 关键字来实现继承。</p>\n<p>TypeScript 4.3 新增了 override 关键字，来确保派生类尝试覆盖的方法一定在基类中存在定义。</p>\n<p>抽象类是对类结构与方法的抽象，简单来说，一个抽象类描述了一个类中应当有哪些成员（属性、方法等），一个抽象方法描述了这一方法在实际实现中的结构。抽象类使用 abstract 关键字声明：</p>\n<pre class=\"language-ts\" tabindex=\"0\"><code class=\"language-ts is-loaded\"><span class=\"token keyword\">abstract</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">AbsFoo</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">abstract</span> absProp<span class=\"token operator\">:</span> <span class=\"token builtin\">string</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">abstract</span> <span class=\"token keyword\">get</span> <span class=\"token function\">absGetter</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token builtin\">string</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">abstract</span> <span class=\"token function\">absMethod</span><span class=\"token punctuation\">(</span>name<span class=\"token operator\">:</span> <span class=\"token builtin\">string</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token builtin\">string</span>\n<span class=\"token punctuation\">}</span>\n</code><button class=\"copy-code-button\">复制</button></pre>\n<p>在 TypeScript 中无法声明静态的抽象成员。对于抽象类，它的本质就是描述类的结构。interface 不仅可以声明函数结构，也可以声明类的结构:</p>\n<pre class=\"language-ts\" tabindex=\"0\"><code class=\"language-ts is-loaded\"><span class=\"token keyword\">interface</span> <span class=\"token class-name\">FooStruct</span> <span class=\"token punctuation\">{</span>\n  absProp<span class=\"token operator\">:</span> <span class=\"token builtin\">string</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">get</span> <span class=\"token function\">absGetter</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token builtin\">string</span><span class=\"token punctuation\">;</span>\n  <span class=\"token function\">absMethod</span><span class=\"token punctuation\">(</span>input<span class=\"token operator\">:</span> <span class=\"token builtin\">string</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token builtin\">string</span>\n<span class=\"token punctuation\">}</span>\n</code><button class=\"copy-code-button\">复制</button></pre>\n<div class=\"block-language-note custom-block note\"><p class=\"custom-block-title\">Note</p><p>interface 怎么声明函数的结构。</p></div>\n<div class=\"block-language-note custom-block note\"><p class=\"custom-block-title\">Note</p><p>JavaScript 中不存在 static 吗？</p></div>",
      "tags": [
        "函数与Class"
      ],
      "createTime": 1665713868427,
      "updateTime": 1665753780987,
      "uuid": "99c21816-87fa-404c-8ac1-67e404036a4a",
      "isCreated": true
    },
    {
      "content": "所有的原始类型与对象类型最终都指向 Object，在 TypeScript 中就表现为 Object 包含了所有的类型：\n\n```ts\n// 对于 undefined、null、void 0 ，需要关闭 strictNullChecks\nconst tmp1: Object = undefined;\nconst tmp2: Object = null;\nconst tmp3: Object = void 0;\n\nconst tmp4: Object = 'linbudu';\nconst tmp5: Object = 599;\nconst tmp6: Object = { name: 'linbudu' };\nconst tmp7: Object = () => {};\nconst tmp8: Object = [];\n```\n\n`Boolean`、`Number`、`String`、`Symbol`，这几个装箱类型（Boxed Types） 同样包含了一些超出预期的类型。以 `String` 为例，它同样包括 `undefined`、`null`、`void`，以及代表的拆箱类型（Unboxed Types） `string`,，但并不包括其他装箱类型对应的拆箱类型。\n\n`object` 的引入就是为了解决对 `Object` 类型的错误使用，它代表所有非原始类型的类型，即数组、对象与函数类型这些：\n\n```ts\nconst tmp17: object = undefined;\nconst tmp18: object = null;\nconst tmp19: object = void 0;\n\nconst tmp20: object = 'linbudu';  // X 不成立，值为原始类型\nconst tmp21: object = 599; // X 不成立，值为原始类型\n\nconst tmp22: object = { name: 'linbudu' };\nconst tmp23: object = () => {};\nconst tmp24: object = [];\n```\n\n```info\n`undefined` 和 `null` 不也是原始类型吗？\n```\n\n可以认为 `{}` 就是一个对象字面量类型（对应到字符串字面量类型这样），它意味着任何非 `null / undefined` 的值。\n\n- 在任何时候都不要，不要，不要使用 `Object` 以及类似的装箱类型。\n- 当你不确定某个变量的具体类型，但能确定它不是原始类型，可以使用 `object`。但我更推荐进一步区分，也就是使用 `Record<string, unknown>` 或 `Record<string, any>` 表示对象，`unknown[]` 或 `any[]` 表示数组，`(...args: any[]) => any`表示函数这样。\n- 我们同样要避免使用 `{}`。`{}` 意味着任何非 `null / undefined` 的值，从这个层面上看，使用它和使用 `any` 一样恶劣。\n\n在 TypeScript 中，`symbol` 类型并不具有这一特性，一百个具有 `symbol` 类型的对象，它们的 `symbol` 类型指的都是 TypeScript 中的同一个类型。为了实现“独一无二”这个特性，TypeScript 中支持了 `unique symbol` 这一类型声明，它是 `symbol` 类型的子类型，每一个 `unique symbol` 类型都是独一无二的。\n\n```ts\nconst uniqueSymbolFoo: unique symbol = Symbol(\"linbudu\")\n\n// 类型不兼容\nconst uniqueSymbolBar: unique symbol = uniqueSymbolFoo\n```\n\n在 TypeScript 中，如果要引用已创建的 `unique symbol` 类型，则需要使用类型查询操作符 `typeof` ：\n\n```ts\ndeclare const uniqueSymbolFoo: unique symbol;\n\nconst uniqueSymbolBaz: typeof uniqueSymbolFoo = uniqueSymbolFoo;\n```\n",
      "preview": "<p>所有的原始类型与对象类型最终都指向 Object，在 TypeScript 中就表现为 Object 包含了所有的类型：</p>\n<pre class=\"language-ts\" tabindex=\"0\"><code class=\"language-ts is-loaded\"><span class=\"token comment\">// 对于 undefined、null、void 0 ，需要关闭 strictNullChecks</span>\n<span class=\"token keyword\">const</span> tmp1<span class=\"token operator\">:</span> Object <span class=\"token operator\">=</span> <span class=\"token keyword\">undefined</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> tmp2<span class=\"token operator\">:</span> Object <span class=\"token operator\">=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> tmp3<span class=\"token operator\">:</span> Object <span class=\"token operator\">=</span> <span class=\"token keyword\">void</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">const</span> tmp4<span class=\"token operator\">:</span> Object <span class=\"token operator\">=</span> <span class=\"token string\">'linbudu'</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> tmp5<span class=\"token operator\">:</span> Object <span class=\"token operator\">=</span> <span class=\"token number\">599</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> tmp6<span class=\"token operator\">:</span> Object <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span> name<span class=\"token operator\">:</span> <span class=\"token string\">'linbudu'</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> tmp7<span class=\"token operator\">:</span> <span class=\"token function-variable function\">Object</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=&gt;</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> tmp8<span class=\"token operator\">:</span> Object <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n</code><button class=\"copy-code-button\">复制</button></pre>\n<p><code>Boolean</code>、<code>Number</code>、<code>String</code>、<code>Symbol</code>，这几个装箱类型（Boxed Types） 同样包含了一些超出预期的类型。以 <code>String</code> 为例，它同样包括 <code>undefined</code>、<code>null</code>、<code>void</code>，以及代表的拆箱类型（Unboxed Types） <code>string</code>,，但并不包括其他装箱类型对应的拆箱类型。</p>\n<p><code>object</code> 的引入就是为了解决对 <code>Object</code> 类型的错误使用，它代表所有非原始类型的类型，即数组、对象与函数类型这些：</p>\n<pre class=\"language-ts\" tabindex=\"0\"><code class=\"language-ts is-loaded\"><span class=\"token keyword\">const</span> tmp17<span class=\"token operator\">:</span> object <span class=\"token operator\">=</span> <span class=\"token keyword\">undefined</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> tmp18<span class=\"token operator\">:</span> object <span class=\"token operator\">=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> tmp19<span class=\"token operator\">:</span> object <span class=\"token operator\">=</span> <span class=\"token keyword\">void</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">const</span> tmp20<span class=\"token operator\">:</span> object <span class=\"token operator\">=</span> <span class=\"token string\">'linbudu'</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\">// X 不成立，值为原始类型</span>\n<span class=\"token keyword\">const</span> tmp21<span class=\"token operator\">:</span> object <span class=\"token operator\">=</span> <span class=\"token number\">599</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// X 不成立，值为原始类型</span>\n\n<span class=\"token keyword\">const</span> tmp22<span class=\"token operator\">:</span> object <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span> name<span class=\"token operator\">:</span> <span class=\"token string\">'linbudu'</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> tmp23<span class=\"token operator\">:</span> <span class=\"token function-variable function\">object</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=&gt;</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> tmp24<span class=\"token operator\">:</span> object <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n</code><button class=\"copy-code-button\">复制</button></pre>\n<div class=\"block-language-info custom-block info\"><p class=\"custom-block-title\">Info</p><p><code>undefined</code> 和 <code>null</code> 不也是原始类型吗？</p></div>\n<p>可以认为 <code>{}</code> 就是一个对象字面量类型（对应到字符串字面量类型这样），它意味着任何非 <code>null / undefined</code> 的值。</p>\n<ul>\n<li>在任何时候都不要，不要，不要使用 <code>Object</code> 以及类似的装箱类型。</li>\n<li>当你不确定某个变量的具体类型，但能确定它不是原始类型，可以使用 <code>object</code>。但我更推荐进一步区分，也就是使用 <code>Record&lt;string, unknown&gt;</code> 或 <code>Record&lt;string, any&gt;</code> 表示对象，<code>unknown[]</code> 或 <code>any[]</code> 表示数组，<code>(...args: any[]) =&gt; any</code>表示函数这样。</li>\n<li>我们同样要避免使用 <code>{}</code>。<code>{}</code> 意味着任何非 <code>null / undefined</code> 的值，从这个层面上看，使用它和使用 <code>any</code> 一样恶劣。</li>\n</ul>\n<p>在 TypeScript 中，<code>symbol</code> 类型并不具有这一特性，一百个具有 <code>symbol</code> 类型的对象，它们的 <code>symbol</code> 类型指的都是 TypeScript 中的同一个类型。为了实现“独一无二”这个特性，TypeScript 中支持了 <code>unique symbol</code> 这一类型声明，它是 <code>symbol</code> 类型的子类型，每一个 <code>unique symbol</code> 类型都是独一无二的。</p>\n<pre class=\"language-ts\" tabindex=\"0\"><code class=\"language-ts is-loaded\"><span class=\"token keyword\">const</span> uniqueSymbolFoo<span class=\"token operator\">:</span> unique <span class=\"token builtin\">symbol</span> <span class=\"token operator\">=</span> <span class=\"token function\">Symbol</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"linbudu\"</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\">// 类型不兼容</span>\n<span class=\"token keyword\">const</span> uniqueSymbolBar<span class=\"token operator\">:</span> unique <span class=\"token builtin\">symbol</span> <span class=\"token operator\">=</span> uniqueSymbolFoo\n</code><button class=\"copy-code-button\">复制</button></pre>\n<p>在 TypeScript 中，如果要引用已创建的 <code>unique symbol</code> 类型，则需要使用类型查询操作符 <code>typeof</code> ：</p>\n<pre class=\"language-ts\" tabindex=\"0\"><code class=\"language-ts is-loaded\"><span class=\"token keyword\">declare</span> <span class=\"token keyword\">const</span> uniqueSymbolFoo<span class=\"token operator\">:</span> unique <span class=\"token builtin\">symbol</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">const</span> uniqueSymbolBaz<span class=\"token operator\">:</span> <span class=\"token keyword\">typeof</span> uniqueSymbolFoo <span class=\"token operator\">=</span> uniqueSymbolFoo<span class=\"token punctuation\">;</span>\n</code><button class=\"copy-code-button\">复制</button></pre>",
      "tags": [
        "原始类型与对象类型"
      ],
      "createTime": 1665665466268,
      "updateTime": 1665667567245,
      "uuid": "eb2db33a-192c-49f2-a978-4060ff88fd51",
      "isCreated": true
    },
    {
      "content": "所有的原始类型与对象类型最终都指向 Object，在 TypeScript 中就表现为 Object 包含了所有的类型：\n\n```ts\n// 对于 undefined、null、void 0 ，需要关闭 strictNullChecks\nconst tmp1: Object = undefined;\nconst tmp2: Object = null;\nconst tmp3: Object = void 0;\n\nconst tmp4: Object = 'linbudu';\nconst tmp5: Object = 599;\nconst tmp6: Object = { name: 'linbudu' };\nconst tmp7: Object = () => {};\nconst tmp8: Object = [];\n```\n\n\n",
      "preview": "<p>所有的原始类型与对象类型最终都指向 Object，在 TypeScript 中就表现为 Object 包含了所有的类型：</p>\n<pre class=\"language-ts\" tabindex=\"0\"><code class=\"language-ts is-loaded\"><span class=\"token comment\">// 对于 undefined、null、void 0 ，需要关闭 strictNullChecks</span>\n<span class=\"token keyword\">const</span> tmp1<span class=\"token operator\">:</span> Object <span class=\"token operator\">=</span> <span class=\"token keyword\">undefined</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> tmp2<span class=\"token operator\">:</span> Object <span class=\"token operator\">=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> tmp3<span class=\"token operator\">:</span> Object <span class=\"token operator\">=</span> <span class=\"token keyword\">void</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">const</span> tmp4<span class=\"token operator\">:</span> Object <span class=\"token operator\">=</span> <span class=\"token string\">'linbudu'</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> tmp5<span class=\"token operator\">:</span> Object <span class=\"token operator\">=</span> <span class=\"token number\">599</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> tmp6<span class=\"token operator\">:</span> Object <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span> name<span class=\"token operator\">:</span> <span class=\"token string\">'linbudu'</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> tmp7<span class=\"token operator\">:</span> <span class=\"token function-variable function\">Object</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=&gt;</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> tmp8<span class=\"token operator\">:</span> Object <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n</code><button class=\"copy-code-button\">复制</button></pre>",
      "tags": [
        "原始类型与对象类型"
      ],
      "createTime": 1665664736833,
      "updateTime": 1665667541330,
      "uuid": "2caf2e33-88a8-4137-9471-d1604e8c6d12",
      "isCreated": true,
      "isDeleted": true
    },
    {
      "content": "VsCode 插件下载：\n\n1. TypeScript Importer\n2. Move TS\n\nVsCode 配置 -> typescript Inlay Hints\n\n- Function Like Return Types，显示推导得到的函数返回值类型；\n- Parameter Names，显示函数入参的名称；\n- Parameter Types，显示函数入参的类型；\n- Variable Types，显示变量的类型。\n\n```note\nWebStorm 上有哪些插件呢？\n```\n\n`ts-node-dev`，可监听文件，自动执行。\n\n```shell\nts-node-dev --respawn --transpile-only app.ts\n```\n\nrespawn 选项启用了监听重启的能力，而 transpileOnly 提供了更快的编译速度。\n\n通过 declare 关键字，我们声明了一个仅在类型空间存在的变量，它在运行时完全不存在。\n\n`tsd` 包，检查类型：\n\n```ts\nimport { expectType } from 'tsd';\n\nexpectType<string>(\"linbudu\"); // √\nexpectType<string>(599); // ×\n```\n",
      "preview": "<p>VsCode 插件下载：</p>\n<ol>\n<li>TypeScript Importer</li>\n<li>Move TS</li>\n</ol>\n<p>VsCode 配置 -&gt; typescript Inlay Hints</p>\n<ul>\n<li>Function Like Return Types，显示推导得到的函数返回值类型；</li>\n<li>Parameter Names，显示函数入参的名称；</li>\n<li>Parameter Types，显示函数入参的类型；</li>\n<li>Variable Types，显示变量的类型。</li>\n</ul>\n<div class=\"block-language-note custom-block note\"><p class=\"custom-block-title\">Note</p><p>WebStorm 上有哪些插件呢？</p></div>\n<p><code>ts-node-dev</code>，可监听文件，自动执行。</p>\n<pre class=\"language-shell\" tabindex=\"0\"><code class=\"language-shell is-loaded\">ts-node-dev --respawn --transpile-only app.ts\n</code><button class=\"copy-code-button\">复制</button></pre>\n<p>respawn 选项启用了监听重启的能力，而 transpileOnly 提供了更快的编译速度。</p>\n<p>通过 declare 关键字，我们声明了一个仅在类型空间存在的变量，它在运行时完全不存在。</p>\n<p><code>tsd</code> 包，检查类型：</p>\n<pre class=\"language-ts\" tabindex=\"0\"><code class=\"language-ts is-loaded\"><span class=\"token keyword\">import</span> <span class=\"token punctuation\">{</span> expectType <span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">'tsd'</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token generic-function\"><span class=\"token function\">expectType</span><span class=\"token generic class-name\"><span class=\"token operator\">&lt;</span><span class=\"token builtin\">string</span><span class=\"token operator\">&gt;</span></span></span><span class=\"token punctuation\">(</span><span class=\"token string\">\"linbudu\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// √</span>\n<span class=\"token generic-function\"><span class=\"token function\">expectType</span><span class=\"token generic class-name\"><span class=\"token operator\">&lt;</span><span class=\"token builtin\">string</span><span class=\"token operator\">&gt;</span></span></span><span class=\"token punctuation\">(</span><span class=\"token number\">599</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// ×</span>\n</code><button class=\"copy-code-button\">复制</button></pre>",
      "tags": [
        "开发环境"
      ],
      "createTime": 1665574401765,
      "updateTime": 1665576793544,
      "uuid": "0cfc22db-76ee-4efc-a3a6-d4ee235208db",
      "isCreated": true
    }
  ]
}