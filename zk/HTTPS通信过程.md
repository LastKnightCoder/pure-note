---
tags: [HTTPS, DH, RSA]
---

HTTP 消息是明文在网络上传输的，所以很有可能被人窃听，为了防止消息被窃听，我们需要对消息进行加密，而加密需要密钥。

加密分为两种，对称加密和非对称加密：

-   对称加密：加密和解密用的是同一种密钥
-   非对称加密：加密和解密用的是不同的密钥

对称加密加解密所需的时间较短，速度较快。

如果使用对称加密，也就是说通信双方使用的同一个密钥，那么双方如何约定这一个密钥呢？如果直接将密钥发送给对方，这个密钥也有可能被窃听，那么加密显得是多此一举，所以必须通过某种方式来安全的传递密钥。

密钥传递有两种方法：

1.  基于 RSA
2.  基于 DH

在 HTTPS 中使用的是 Diffie-Hellman 密钥交换算法来传递公钥，这个算法可以合成两个密钥为一个密钥，合成算法具有如下特点：

1.  已知其中一个密钥以及合成后的密钥，无法反推出另一个密钥
    
    密钥 A 和 密钥 B 合成出密钥 AB，已知 A 和 AB 是无法反推出 B 的
    
2.  合成的密钥可以继续与其他密钥进行合成
    
    A + B → AB，AB + C → ABC
    
3.  合成的密钥与合成的顺序无关
    
    A + B → AB, AB + C → ABC
    
    A + C → AC, AC + B → ACB
    
    ABC = ACB
    

基于这三个原则我们就可以合成一个公钥，并且该公钥不可能被窃取，具体做法如下：

1.  通信双方各自生成一个密钥，该密钥不会单独在网络上传播，不妨分别记为A，B
2.  通信一方生成一个密钥 C，发送给另一方，该密钥可能被窃取，但是没有关系
3.  二者分别使用各自生成的密钥使用上述算法与 C 进行合成，分别得到 AC 与 BC，然后分别发送给对方，AC 与 BC 也可能被窃取，不过已知 AC 和 BC 以及 C 的情况下，根据算法的第一个特点，是无法反推出 A 和 B 的
4.  双方拿到 AC 或 BC 之后，根据算法的第二个特点，AC 与 BC 还可以继续合成，分别与自己生成的密钥合成，形成 ACB 或者 BCA，根据算法的第三个特点二者是相同的，可以作为对称加密的密钥

密钥交换算法可以解决加密的问题，但是却无法解决身份的问题。

假设 A 要与 B 通信，C 是窃听者，那么 C 可以假冒 B 与 A 进行通信，二者进行了密钥交换；对于 B 来说，C 假冒为 A 与其通信，二者进行了密钥交换，虽然通信的消息是加密的，但是发错了人。这就是中间人攻击，正是因为无法确定对方的身份，所以才会使得第三方有机可乘。

为了解决中间人攻击，我们需要在密钥交换前先进行身份认证，这个就需要数字证书。如果用户在与服务器通信时，如果没有收到数字证书，那么就可以认为此次通信是不安全的，拿到数字证书之后，我们需要查看证书的内容，明确对方的身份，我们才能放心的发送消息。

我们需要验证证书的两个方面：证书所有者以及证书是否可信。证书不是可以随便制作的，它必须有第三方的权威认证机构（CA）才能发放，我们需要证书则必须向它们申请。当我们申请到证书以后，就可以将证书发送给浏览器，为了防止证书被篡改，我们需要发送证书的签名，该签名是由发放该证书的 CA 使用私钥对其摘要加密形成的，浏览器收到证书后，会通过内置的 CA 公钥验证签名是否正确，如果正确说明证书没有被篡改，并且的确是 CA 发放的，从而证明证书是可信的。

那么如何证明服务器的确是证书的所有者呢？在证书里面会包含申请证书时提交的公钥，如果服务器包含有对应的私钥，那么就可以证明服务器是证书的持有者。那么如何证明服务器包含对应的私钥呢，因为密钥交换有两种方法：

1.  基于 RSA：浏览器在验证证书签名没有问题以后，会提取出其中的公钥，并且在本地生成一个用于加密通信的密钥，然后使用公钥对该密钥进行加密，发送给服务器，服务器使用私钥进行解密，拿到用于通信的密钥。如果服务器没有私钥，那么后续加密通信就无法完成，所以此操作完成了两个目的，一个是密钥的传递，另一个就是证书身份的确认。
2.  基于 DH 密钥交换算法：服务器首先会对二者交换的随机数以及服务器端用于交换算法的参数进行 Hash 运算，然后对运算结果使用私钥加密，然后发送给浏览器，浏览器会同样对二者交换的随机数以及服务器发送的参数进行 Hash 运算，并使用公钥对发送的签名进行解密，如果二者相同，那么就说明服务器持有私钥。

``` tip
👉 证书的申请价格不菲，且具有过期时间。
```